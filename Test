--[[
	Test script for Roblox game.
	Small UI that gets the local player and displays the player's name.
	Reference: Roblox/Referrence/JunkieKeySystem Example.lua
]]

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Remove any existing UI so we don't stack
local existing = PlayerGui:FindFirstChild("PlayerNameTest")
if existing then
	existing:Destroy()
end

-- Test: get player name
local function getPlayerName()
	return LocalPlayer.Name or "Unknown"
end

-- Build small UI
local screen = Instance.new("ScreenGui")
screen.Name = "PlayerNameTest"
screen.ResetOnSpawn = false
screen.Parent = PlayerGui

-- Speed slider range (Roblox default WalkSpeed is 16)
local MIN_WALK_SPEED = 8
local MAX_WALK_SPEED = 300
local DEFAULT_WALK_SPEED = 16

-- Objects list: only show instances whose Name contains any of these (case-insensitive)
local OBJECTS_LIST_NAME_FILTERS = { "Bubu", "Toffee", "Noob" }
-- Objects list: only show models whose FullName starts with this path (e.g. Workspace.Map.Zones.Field includes Field and all descendants); set to nil or "" to skip
local OBJECTS_LIST_PARENT_FILTER = "Workspace.Map.Zones.Field.NPC"

-- Take Bubu with E: max distance to consider "near" the player (studs)
local TAKE_BUBU_MAX_RANGE = 30
-- First teleport after taking Bubu; then step teleport (Z only) until Z = -30, then MoveTo to Z = -10 (X,Y unchanged)
local TELEPORT_FIRST_EXIT = Vector3.new(-35, 4.2, -31)
-- Step teleport back: change only Z until we reach this (then MoveTo from here to Z = -10)
local TELEPORT_BACK_Z_END = -30
local TELEPORT_BACK_Z_STEP = 10
-- MoveTo goes to (same X, same Y, -10). "Teleport back" button uses this.
local OUTSIDE_FIELD_POSITION = Vector3.new(-22, 4.2, -10)
-- MoveTo to outside: max time (s) and distance (studs) to consider "arrived"
local WALK_TO_OUTSIDE_TIMEOUT = 20
local WALK_ARRIVED_DISTANCE = 4
-- Simulate hold E for pickup: duration in seconds (then we MoveTo to Z)
local HOLD_E_DURATION = 2
-- Optional: set to a path string (e.g. "ReplicatedStorage.Remotes.Field.PickupNPCStateChanged") to use that remote; nil = auto-detect
local TAKE_REMOTE_PATH = nil
-- Known pickup remotes (tried in order when TAKE_REMOTE_PATH is nil)
local TAKE_REMOTE_CANDIDATES = {
	"ReplicatedStorage.Remotes.Field.PickupNPCStateChanged",
	"ReplicatedStorage.Remotes.Plot.PickupSlotNPC",
}

local workspace = game:GetService("Workspace")

-- Simulate press and hold E for a duration (for pickup). Uses VirtualInputManager if available.
local function holdEKey(durationSeconds)
	durationSeconds = durationSeconds or HOLD_E_DURATION
	local ok, vim = pcall(function() return game:GetService("VirtualInputManager") end)
	if ok and vim and vim.SendKeyEvent then
		vim:SendKeyEvent(true, Enum.KeyCode.E, false, game)
		task.wait(durationSeconds)
		vim:SendKeyEvent(false, Enum.KeyCode.E, false, game)
		return true
	end
	task.wait(durationSeconds)
	return false
end

-- Get all Bubu models (path match; include if Mutation ~= Normal, or if Mutation is Normal but Rarity is Secret/Exclusive)
local function getCharacterInfoLabelTopLevel(model, labelName)
	for _, desc in ipairs(model:GetDescendants()) do
		if desc:IsA("BillboardGui") and desc.Name == "CharacterInfo" then
			local lbl = desc:FindFirstChild(labelName, true)
			if lbl and (lbl:IsA("TextLabel") or lbl:IsA("TextButton")) and lbl.Text then
				return lbl.Text
			end
			break
		end
	end
	local charInfo = model:FindFirstChild("CharacterInfo", true)
	if charInfo then
		local gui = charInfo:IsA("BillboardGui") and charInfo or charInfo:FindFirstChildOfClass("BillboardGui")
		if gui then
			local lbl = gui:FindFirstChild(labelName, true)
			if lbl and (lbl:IsA("TextLabel") or lbl:IsA("TextButton")) and lbl.Text then
				return lbl.Text
			end
		end
	end
	return nil
end

local function getBubuModels()
	local collected = {}
	local prefix = OBJECTS_LIST_PARENT_FILTER
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj.ClassName == "Model" then
			local fullName = obj:GetFullName()
			local parentMatch = not prefix or prefix == ""
				or (fullName == prefix or string.sub(fullName, 1, #prefix + 1) == prefix .. ".")
			if parentMatch then
				local mutation = obj:GetAttribute("Mutation")
				if mutation ~= nil then
					local rarity = getCharacterInfoLabelTopLevel(obj, "Rarity")
					local includeByMutation = (mutation ~= "Normal")
						or (mutation == "Normal" and (rarity == "Secret" or rarity == "Exclusive"))
					if includeByMutation then
						local excludeGoldDiamondLowRarity = (mutation == "Gold" or mutation == "Diamond")
							and (rarity == "Common" or rarity == "Uncommon" or rarity == "Rare")
						if not excludeGoldDiamondLowRarity then
							table.insert(collected, obj)
						end
					end
				end
			end
		end
	end
	return collected
end

-- Rarity sort (same as list: rarest first). Used for "Go to top" and E-hold teleport.
local RARITY_ORDER = {
	Exclusive = 1, Secret = 2, God = 3, Mythic = 4, Legendary = 5,
	Epic = 6, Rare = 7, Uncommon = 8, Common = 9
}
local function raritySortKey(rarityStr)
	if not rarityStr or rarityStr == "" then return 99 end
	return RARITY_ORDER[rarityStr] or 99
end
local function getSortedBubuListTopLevel()
	local collected = getBubuModels()
	table.sort(collected, function(a, b)
		return raritySortKey(getCharacterInfoLabelTopLevel(a, "Rarity")) < raritySortKey(getCharacterInfoLabelTopLevel(b, "Rarity"))
	end)
	return collected
end
-- Position of top Bubu (rarest), 4 studs in front; same as "Go to top" button. Returns nil if no Bubus.
local function getTopBubuPosition()
	local sorted = getSortedBubuListTopLevel()
	if #sorted == 0 then return nil end
	local topModel = sorted[1]
	local ok, pivot = pcall(function() return topModel:GetPivot() end)
	if ok and pivot then
		return pivot.Position + Vector3.new(0, 0, 4)
	end
	if topModel.PrimaryPart then
		return topModel.PrimaryPart.Position + Vector3.new(0, 0, 4)
	end
	return nil
end

local function resolveRemotePath(pathString)
	local node = game
	for part in string.gmatch(pathString, "[^.]+") do
		node = node:FindFirstChild(part)
		if not node then return nil end
	end
	if node:IsA("RemoteEvent") or node:IsA("RemoteFunction") then return node end
	return nil
end

-- Find a remote that might be the game's "take/capture" API. Tries TAKE_REMOTE_PATH, then TAKE_REMOTE_CANDIDATES, then name scan.
local function findTakeRemote()
	if type(TAKE_REMOTE_PATH) == "string" and TAKE_REMOTE_PATH ~= "" then
		local r = resolveRemotePath(TAKE_REMOTE_PATH)
		if r then return r end
	end
	for _, path in ipairs(TAKE_REMOTE_CANDIDATES or {}) do
		local r = resolveRemotePath(path)
		if r then return r end
	end
	local keywords = { "take", "capture", "pick", "collect", "catch", "bubu", "pet", "npc", "add", "pickup" }
	local function nameMatches(name)
		local lower = string.lower(name or "")
		for _, kw in ipairs(keywords) do
			if string.find(lower, kw) then return true end
		end
		return false
	end
	for _, child in ipairs(ReplicatedStorage:GetDescendants()) do
		if (child:IsA("RemoteEvent") or child:IsA("RemoteFunction")) and nameMatches(child.Name) then
			return child
		end
	end
	for _, child in ipairs(ReplicatedStorage:GetChildren()) do
		if (child:IsA("RemoteEvent") or child:IsA("RemoteFunction")) and nameMatches(child.Name) then
			return child
		end
	end
	return nil
end

-- Try to take the Bubu via the game's remote. For PickupNPCStateChanged, mimics "hold E 2 sec": fire true, wait 2, fire false.
local function tryTakeViaRemote(nearest)
	local remote = findTakeRemote()
	if not remote then
		print("[Take] No take remote found. Set TAKE_REMOTE_PATH at top of script if you know the path.")
		return false
	end
	local id = nearest:GetAttribute("NPCId") or nearest:GetAttribute("NpcId") or nearest.Name
	local fullName = remote:GetFullName()
	local isStateChanged = string.find(fullName, "PickupNPCStateChanged")

	local function fireRemote(...)
		local a = { ... }
		if remote:IsA("RemoteEvent") then
			remote:FireServer(table.unpack(a))
		else
			remote:InvokeServer(table.unpack(a))
		end
	end

	-- If this is the "state changed" remote: only fire (pickTarget, true) and wait 2s. Do NOT fire false here –
	-- we release after teleport + walk so the Bubu doesn’t drop in the field. Call releasePickupState(nearest) after arriving.
	if isStateChanged then
		local function tryStartPickup(pickTarget)
			return pcall(function() fireRemote(pickTarget, true) end)
		end
		if tryStartPickup(nearest) then
			print("[Take] Called PickupNPCStateChanged(nearest, true). Step teleport then MoveTo.")
			return true
		end
		if tryStartPickup(id) then
			print("[Take] Called PickupNPCStateChanged(id, true). Step teleport then MoveTo.")
			return true
		end
		if tryStartPickup(nearest.Name) then
			print("[Take] Called PickupNPCStateChanged(nearest.Name, true). Step teleport then MoveTo.")
			return true
		end
		if pcall(function() fireRemote(true) end) then
			print("[Take] Called PickupNPCStateChanged true. Step teleport then MoveTo.")
			return true
		end
	end

	-- Otherwise try common argument patterns
	local argsList = {
		{ true },
		{ nearest, true },
		{ true, nearest },
		{ nearest },
		{ nearest.Name },
		{ id },
		{ id, nearest },
		{ nearest, LocalPlayer },
		{ 1, nearest },
		{ 1, id },
	}
	for _, args in ipairs(argsList) do
		local ok, err = pcall(function() fireRemote(table.unpack(args)) end)
		if ok then
			print("[Take] Called remote:", fullName, "with args count:", #args)
			return true
		end
	end
	print("[Take] Remote", fullName, "failed all argument patterns. Try setting TAKE_REMOTE_PATH and correct args.")
	return false
end

-- Release pickup state after we’ve teleported and walked outside (so Bubu doesn’t drop in the field).
local function releasePickupState(nearest)
	if not nearest or not nearest.Parent then return end
	local remote = findTakeRemote()
	if not remote then return end
	local fullName = remote:GetFullName()
	if not string.find(fullName, "PickupNPCStateChanged") then return end
	local id = nearest:GetAttribute("NPCId") or nearest:GetAttribute("NpcId") or nearest.Name
	local function fire(...)
		if remote:IsA("RemoteEvent") then remote:FireServer(...) else remote:InvokeServer(...) end
	end
	pcall(function() fire(nearest, false) end)
	pcall(function() fire(id, false) end)
	pcall(function() fire(false) end)
end

-- Print all RemoteEvents/RemoteFunctions under ReplicatedStorage to Output (use "List remotes" button or call once).
local function listAllRemotes()
	local list = {}
	for _, child in ipairs(ReplicatedStorage:GetDescendants()) do
		if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
			table.insert(list, child:GetFullName())
		end
	end
	table.sort(list)
	print("---- ReplicatedStorage remotes (set TAKE_REMOTE_PATH to one of these if you find the take/capture one) ----")
	for _, path in ipairs(list) do
		print("  ", path)
	end
	print("---- Total:", #list, "remotes ----")
	return list
end

-- Walk character to target position (Humanoid:MoveTo). Runs in a spawned thread so it doesn't block.
local function walkToPosition(character, targetPos, timeoutSeconds, arrivedDist)
	local humanoid = character and character:FindFirstChildOfClass("Humanoid")
	local root = character and character:FindFirstChild("HumanoidRootPart")
	if not humanoid or not root then return end
	timeoutSeconds = timeoutSeconds or WALK_TO_OUTSIDE_TIMEOUT
	arrivedDist = arrivedDist or WALK_ARRIVED_DISTANCE
	humanoid:MoveTo(targetPos)
	local start = os.clock()
	while (root.Position - targetPos).Magnitude > arrivedDist and (os.clock() - start) < timeoutSeconds do
		task.wait(0.2)
		if (root.Position - targetPos).Magnitude > arrivedDist then
			humanoid:MoveTo(targetPos)
		end
	end
	-- Snap to target if close (optional)
	if (root.Position - targetPos).Magnitude <= arrivedDist * 2 then
		root.CFrame = CFrame.new(targetPos)
	end
end

-- Take nearest Bubu and teleport (player + Bubu) to outside the field. Optional onArrived() called when MoveTo finishes.
local function takeNearestBubuAndTeleportOutside(onArrived)
	local character = LocalPlayer.Character
	if not character then return end
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then return end
	local playerPos = root.Position
	local bubus = getBubuModels()
	local nearest = nil
	local nearestDist = TAKE_BUBU_MAX_RANGE
	for _, model in ipairs(bubus) do
		local pos = nil
		local ok, pivot = pcall(function() return model:GetPivot() end)
		if ok and pivot then pos = pivot.Position
		elseif model.PrimaryPart then pos = model.PrimaryPart.Position
		end
		if not pos then continue end
		local dist = (pos - playerPos).Magnitude
		if dist < nearestDist then
			nearestDist = dist
			nearest = model
		end
	end
	-- Use MoveTo only: hold E then walk from current position to (same X, same Y, -10). Optional onArrived() when done.
	local startPos = root.Position
	local x, y = startPos.X, startPos.Y
	task.spawn(function()
		local char = LocalPlayer.Character
		if not char then if onArrived then onArrived() end return end
		task.wait(0.2)
		holdEKey(HOLD_E_DURATION)
		local moveToTarget = Vector3.new(x, y, -10)
		walkToPosition(char, moveToTarget, WALK_TO_OUTSIDE_TIMEOUT, WALK_ARRIVED_DISTANCE)
		if nearest then releasePickupState(nearest) end
		if onArrived then onArrived() end
	end)
end

-- Full flow: teleport to top Bubu → hold E → take nearest Bubu and MoveTo outside. Optional onArrived() when arrived.
local function goToTopThenTakeAndTeleportOutside(onArrived)
	local topPos = getTopBubuPosition()
	if not topPos then if onArrived then onArrived() end return end
	local character = LocalPlayer.Character
	if not character then if onArrived then onArrived() end return end
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then if onArrived then onArrived() end return end
	-- 1) Teleport to top Bubu (you are now near the best NPC)
	root.CFrame = CFrame.new(topPos)
	-- 2) At that moment hold E to pick up the NPC (no delay – hold right away)
	holdEKey(HOLD_E_DURATION)
	-- 3) Then MoveTo to (same X, same Y, -10)
	takeNearestBubuAndTeleportOutside(onArrived)
end

local main = Instance.new("Frame")
main.Name = "Main"
main.Size = UDim2.new(0, 220, 0, 268)
main.Position = UDim2.new(0, 16, 0, 16)
main.BackgroundColor3 = Color3.fromRGB(20, 30, 50)
main.BorderSizePixel = 0
main.Active = true  -- allow dragging from window background
main.Parent = screen

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 10)
corner.Parent = main

-- Top bar (drag handle)
local top = Instance.new("Frame")
top.Name = "Top"
top.Size = UDim2.new(1, 0, 0, 28)
top.Position = UDim2.new(0, 0, 0, 0)
top.BackgroundColor3 = Color3.fromRGB(30, 60, 100)
top.BorderSizePixel = 0
top.Active = true  -- required for InputBegan to fire on drag handle
top.Parent = main

local topCorner = Instance.new("UICorner")
topCorner.CornerRadius = UDim.new(0, 10)
topCorner.Parent = top

local topCover = Instance.new("Frame")
topCover.Size = UDim2.new(1, 0, 0, 14)
topCover.Position = UDim2.new(0, 0, 1, -14)
topCover.BackgroundColor3 = Color3.fromRGB(30, 60, 100)
topCover.BorderSizePixel = 0
topCover.Parent = top

local bar = Instance.new("Frame")
bar.Name = "Bar"
bar.Size = UDim2.new(1, 0, 0, 4)
bar.Position = UDim2.new(0, 0, 0, 28)
bar.BackgroundColor3 = Color3.fromRGB(90, 170, 255)
bar.BorderSizePixel = 0
bar.Active = true  -- drag handle
bar.Parent = main

local barCorner = Instance.new("UICorner")
barCorner.CornerRadius = UDim.new(0, 2)
barCorner.Parent = bar

local title = Instance.new("TextLabel")
title.Name = "Title"
title.Size = UDim2.new(1, -44, 0, 28)
title.Position = UDim2.new(0, 8, 0, 0)
title.BackgroundTransparency = 1
title.Active = true  -- required for InputBegan to fire on drag handle
title.Text = "Player Name Test"
title.TextColor3 = Color3.fromRGB(200, 230, 255)
title.TextSize = 14
title.Font = Enum.Font.GothamBold
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = top

local closeBtn = Instance.new("TextButton")
closeBtn.Name = "Close"
closeBtn.Size = UDim2.new(0, 28, 0, 28)
closeBtn.Position = UDim2.new(1, -28, 0, 0)
closeBtn.BackgroundTransparency = 1
closeBtn.Text = "×"
closeBtn.TextColor3 = Color3.fromRGB(200, 230, 255)
closeBtn.TextSize = 20
closeBtn.Font = Enum.Font.GothamBold
closeBtn.Parent = top

-- Drag state and connection (so we can disconnect when UI closes)
local mainDragging = false
local dragStart, startPos
local inputChangedConnection, inputEndedConnection

local function startDrag(inp)
	if inp.UserInputType == Enum.UserInputType.MouseButton1 then
		mainDragging = true
		dragStart = inp.Position
		startPos = main.Position
	end
end

-- Connect drag to top bar, title, bar, and main window background
top.InputBegan:Connect(startDrag)
title.InputBegan:Connect(startDrag)
bar.InputBegan:Connect(startDrag)
main.InputBegan:Connect(startDrag)

inputChangedConnection = UserInputService.InputChanged:Connect(function(inp)
	if mainDragging and inp.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = inp.Position - dragStart
		main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
end)

inputEndedConnection = UserInputService.InputEnded:Connect(function(inp)
	if inp.UserInputType == Enum.UserInputType.MouseButton1 then
		mainDragging = false
	end
end)

closeBtn.MouseButton1Click:Connect(function()
	if inputChangedConnection then inputChangedConnection:Disconnect() inputChangedConnection = nil end
	if inputEndedConnection then inputEndedConnection:Disconnect() inputEndedConnection = nil end
	if positionConnection then positionConnection:Disconnect() positionConnection = nil end
	screen:Destroy()
end)

local nameLabel = Instance.new("TextLabel")
nameLabel.Name = "PlayerName"
nameLabel.Size = UDim2.new(1, -16, 0, 24)
nameLabel.Position = UDim2.new(0, 8, 0, 36)
nameLabel.BackgroundTransparency = 1
nameLabel.Text = getPlayerName()
nameLabel.TextColor3 = Color3.new(1, 1, 1)
nameLabel.TextSize = 16
nameLabel.Font = Enum.Font.Gotham
nameLabel.TextXAlignment = Enum.TextXAlignment.Left
nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
nameLabel.Parent = main

-- Keep UI in sync if display name or name changes
LocalPlayer:GetPropertyChangedSignal("Name"):Connect(function()
	nameLabel.Text = getPlayerName()
end)

-- Speed slider
local speedLabel = Instance.new("TextLabel")
speedLabel.Name = "SpeedLabel"
speedLabel.Size = UDim2.new(0, 60, 0, 20)
speedLabel.Position = UDim2.new(0, 8, 0, 64)
speedLabel.BackgroundTransparency = 1
speedLabel.Text = "Speed"
speedLabel.TextColor3 = Color3.fromRGB(200, 230, 255)
speedLabel.TextSize = 12
speedLabel.Font = Enum.Font.Gotham
speedLabel.TextXAlignment = Enum.TextXAlignment.Left
speedLabel.Parent = main

local speedValueLabel = Instance.new("TextLabel")
speedValueLabel.Name = "SpeedValue"
speedValueLabel.Size = UDim2.new(0, 44, 0, 20)
speedValueLabel.Position = UDim2.new(1, -52, 0, 64)
speedValueLabel.BackgroundTransparency = 1
speedValueLabel.Text = tostring(DEFAULT_WALK_SPEED)
speedValueLabel.TextColor3 = Color3.fromRGB(200, 230, 255)
speedValueLabel.TextSize = 12
speedValueLabel.Font = Enum.Font.Gotham
speedValueLabel.TextXAlignment = Enum.TextXAlignment.Right
speedValueLabel.Parent = main

local sliderTrack = Instance.new("Frame")
sliderTrack.Name = "SliderTrack"
sliderTrack.Size = UDim2.new(1, -16, 0, 12)
sliderTrack.Position = UDim2.new(0, 8, 0, 88)
sliderTrack.BackgroundColor3 = Color3.fromRGB(40, 50, 70)
sliderTrack.BorderSizePixel = 0
sliderTrack.Active = true
sliderTrack.Parent = main

local sliderTrackCorner = Instance.new("UICorner")
sliderTrackCorner.CornerRadius = UDim.new(0, 6)
sliderTrackCorner.Parent = sliderTrack

local sliderFill = Instance.new("Frame")
sliderFill.Name = "Fill"
sliderFill.Size = UDim2.new(0, 0, 1, 0)
sliderFill.Position = UDim2.new(0, 0, 0, 0)
sliderFill.BackgroundColor3 = Color3.fromRGB(90, 170, 255)
sliderFill.BorderSizePixel = 0
sliderFill.ZIndex = 0
sliderFill.Parent = sliderTrack

local sliderFillCorner = Instance.new("UICorner")
sliderFillCorner.CornerRadius = UDim.new(0, 6)
sliderFillCorner.Parent = sliderFill

local sliderThumb = Instance.new("Frame")
sliderThumb.Name = "Thumb"
sliderThumb.Size = UDim2.new(0, 14, 0, 14)
sliderThumb.Position = UDim2.new(0, -7, 0.5, -7)
sliderThumb.AnchorPoint = Vector2.new(0.5, 0.5)
sliderThumb.BackgroundColor3 = Color3.fromRGB(200, 230, 255)
sliderThumb.BorderSizePixel = 0
sliderThumb.ZIndex = 1
sliderThumb.Active = true
sliderThumb.Parent = sliderTrack

local sliderThumbCorner = Instance.new("UICorner")
sliderThumbCorner.CornerRadius = UDim.new(1, 0)
sliderThumbCorner.Parent = sliderThumb

-- Objects list button
local objectsBtn = Instance.new("TextButton")
objectsBtn.Name = "Objects"
objectsBtn.Size = UDim2.new(1, -16, 0, 28)
objectsBtn.Position = UDim2.new(0, 8, 0, 108)
objectsBtn.BackgroundColor3 = Color3.fromRGB(40, 70, 120)
objectsBtn.BorderSizePixel = 0
objectsBtn.Text = "Spawned Bubus"
objectsBtn.TextColor3 = Color3.fromRGB(200, 230, 255)
objectsBtn.TextSize = 12
objectsBtn.Font = Enum.Font.Gotham
objectsBtn.Parent = main

local objectsBtnCorner = Instance.new("UICorner")
objectsBtnCorner.CornerRadius = UDim.new(0, 6)
objectsBtnCorner.Parent = objectsBtn

-- Collect All Cash button (calls ReplicatedStorage.CollectAllCash)
local collectCashBtn = Instance.new("TextButton")
collectCashBtn.Name = "CollectCash"
collectCashBtn.Size = UDim2.new(1, -16, 0, 28)
collectCashBtn.Position = UDim2.new(0, 8, 0, 140)
collectCashBtn.BackgroundColor3 = Color3.fromRGB(50, 90, 60)
collectCashBtn.BorderSizePixel = 0
collectCashBtn.Text = "Collect All Cash"
collectCashBtn.TextColor3 = Color3.fromRGB(200, 255, 220)
collectCashBtn.TextSize = 12
collectCashBtn.Font = Enum.Font.Gotham
collectCashBtn.Parent = main

local collectCashBtnCorner = Instance.new("UICorner")
collectCashBtnCorner.CornerRadius = UDim.new(0, 6)
collectCashBtnCorner.Parent = collectCashBtn

-- Go to top button (main screen) – same as in Spawned Bubus: teleport to top Bubu, then take + teleport outside after 2s
local goToTopBtn = Instance.new("TextButton")
goToTopBtn.Name = "GoToTop"
goToTopBtn.Size = UDim2.new(0.5, -10, 0, 28)
goToTopBtn.Position = UDim2.new(0, 8, 0, 174)
goToTopBtn.BackgroundColor3 = Color3.fromRGB(50, 80, 120)
goToTopBtn.BorderSizePixel = 0
goToTopBtn.Text = "Go to top"
goToTopBtn.TextColor3 = Color3.fromRGB(200, 230, 255)
goToTopBtn.TextSize = 12
goToTopBtn.Font = Enum.Font.Gotham
goToTopBtn.Parent = main

local goToTopBtnCorner = Instance.new("UICorner")
goToTopBtnCorner.CornerRadius = UDim.new(0, 6)
goToTopBtnCorner.Parent = goToTopBtn

-- Teleport back button (main screen) – teleport to outside field position
local teleportBackBtn = Instance.new("TextButton")
teleportBackBtn.Name = "TeleportBack"
teleportBackBtn.Size = UDim2.new(0.5, -10, 0, 28)
teleportBackBtn.Position = UDim2.new(0.5, 2, 0, 174)
teleportBackBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 90)
teleportBackBtn.BorderSizePixel = 0
teleportBackBtn.Text = "Teleport back"
teleportBackBtn.TextColor3 = Color3.fromRGB(230, 200, 255)
teleportBackBtn.TextSize = 11
teleportBackBtn.Font = Enum.Font.Gotham
teleportBackBtn.Parent = main

local teleportBackBtnCorner = Instance.new("UICorner")
teleportBackBtnCorner.CornerRadius = UDim.new(0, 6)
teleportBackBtnCorner.Parent = teleportBackBtn

-- Start collecting NPCs button (under Go to top row)
local startCollectBtn = Instance.new("TextButton")
startCollectBtn.Name = "StartCollect"
startCollectBtn.Size = UDim2.new(0.5, -10, 0, 28)
startCollectBtn.Position = UDim2.new(0, 8, 0, 208)
startCollectBtn.BackgroundColor3 = Color3.fromRGB(40, 90, 50)
startCollectBtn.BorderSizePixel = 0
startCollectBtn.Text = "Start collecting NPCs"
startCollectBtn.TextColor3 = Color3.fromRGB(200, 255, 220)
startCollectBtn.TextSize = 10
startCollectBtn.Font = Enum.Font.Gotham
startCollectBtn.Parent = main

local startCollectBtnCorner = Instance.new("UICorner")
startCollectBtnCorner.CornerRadius = UDim.new(0, 6)
startCollectBtnCorner.Parent = startCollectBtn

-- Stop collecting NPCs button
local stopCollectBtn = Instance.new("TextButton")
stopCollectBtn.Name = "StopCollect"
stopCollectBtn.Size = UDim2.new(0.5, -10, 0, 28)
stopCollectBtn.Position = UDim2.new(0.5, 2, 0, 208)
stopCollectBtn.BackgroundColor3 = Color3.fromRGB(90, 40, 40)
stopCollectBtn.BorderSizePixel = 0
stopCollectBtn.Text = "Stop collecting"
stopCollectBtn.TextColor3 = Color3.fromRGB(255, 200, 200)
stopCollectBtn.TextSize = 11
stopCollectBtn.Font = Enum.Font.Gotham
stopCollectBtn.Parent = main

local stopCollectBtnCorner = Instance.new("UICorner")
stopCollectBtnCorner.CornerRadius = UDim.new(0, 6)
stopCollectBtnCorner.Parent = stopCollectBtn

local collectingActive = false
local function runCollectingLoop()
	while collectingActive do
		local list = getSortedBubuListTopLevel()
		if #list == 0 then
			task.wait(2)
		else
			local arrived = false
			goToTopThenTakeAndTeleportOutside(function() arrived = true end)
			while not arrived and collectingActive do
				task.wait(0.5)
			end
			if not collectingActive then break end
			task.wait(1)
		end
	end
end

-- Player position display
local positionLabel = Instance.new("TextLabel")
positionLabel.Name = "Position"
positionLabel.Size = UDim2.new(1, -16, 0, 20)
positionLabel.Position = UDim2.new(0, 8, 0, 242)
positionLabel.BackgroundTransparency = 1
positionLabel.Text = "Position: --, --, --"
positionLabel.TextColor3 = Color3.fromRGB(180, 210, 255)
positionLabel.TextSize = 11
positionLabel.Font = Enum.Font.Gotham
positionLabel.TextXAlignment = Enum.TextXAlignment.Left
positionLabel.TextTruncate = Enum.TextTruncate.AtEnd
positionLabel.Parent = main

local positionConnection
local function updatePositionDisplay()
	local character = LocalPlayer.Character
	if not character then
		positionLabel.Text = "Position: (no character)"
		return
	end
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then
		positionLabel.Text = "Position: (no root)"
		return
	end
	local p = root.Position
	positionLabel.Text = string.format("Position: %.1f, %.1f, %.1f", p.X, p.Y, p.Z)
end
positionConnection = RunService.Heartbeat:Connect(updatePositionDisplay)
updatePositionDisplay()

-- Objects list window (new window when button clicked)
local function openObjectsWindow()
	local existingObjGui = PlayerGui:FindFirstChild("PlayerNameTest_ObjectsList")
	if existingObjGui then
		existingObjGui:Destroy()
	end

	local objScreen = Instance.new("ScreenGui")
	objScreen.Name = "PlayerNameTest_ObjectsList"
	objScreen.ResetOnSpawn = false
	objScreen.Parent = PlayerGui

	local objMain = Instance.new("Frame")
	objMain.Name = "Main"
	objMain.Size = UDim2.new(0, 320, 0, 400)
	objMain.Position = UDim2.new(0.5, -160, 0.5, -200)
	objMain.AnchorPoint = Vector2.new(0.5, 0.5)
	objMain.BackgroundColor3 = Color3.fromRGB(20, 30, 50)
	objMain.BorderSizePixel = 0
	objMain.Active = true  -- allow dragging from window background
	objMain.Parent = objScreen

	local objCorner = Instance.new("UICorner")
	objCorner.CornerRadius = UDim.new(0, 10)
	objCorner.Parent = objMain

	local objTop = Instance.new("Frame")
	objTop.Name = "Top"
	objTop.Size = UDim2.new(1, 0, 0, 28)
	objTop.Position = UDim2.new(0, 0, 0, 0)
	objTop.BackgroundColor3 = Color3.fromRGB(30, 60, 100)
	objTop.BorderSizePixel = 0
	objTop.Active = true
	objTop.Parent = objMain

	local objTopCorner = Instance.new("UICorner")
	objTopCorner.CornerRadius = UDim.new(0, 10)
	objTopCorner.Parent = objTop

	local objTitle = Instance.new("TextLabel")
	objTitle.Name = "Title"
	objTitle.Size = UDim2.new(1, -148, 0, 28)
	objTitle.Position = UDim2.new(0, 8, 0, 0)
	objTitle.BackgroundTransparency = 1
	objTitle.Active = true
	objTitle.Text = "Spawned Bubus"
	objTitle.TextColor3 = Color3.fromRGB(200, 230, 255)
	objTitle.TextSize = 14
	objTitle.Font = Enum.Font.GothamBold
	objTitle.TextXAlignment = Enum.TextXAlignment.Left
	objTitle.Parent = objTop

	local objCloseBtn = Instance.new("TextButton")
	objCloseBtn.Name = "Close"
	objCloseBtn.Size = UDim2.new(0, 28, 0, 28)
	objCloseBtn.Position = UDim2.new(1, -28, 0, 0)
	objCloseBtn.BackgroundTransparency = 1
	objCloseBtn.Text = "×"
	objCloseBtn.TextColor3 = Color3.fromRGB(200, 230, 255)
	objCloseBtn.TextSize = 20
	objCloseBtn.Font = Enum.Font.GothamBold
	objCloseBtn.Parent = objTop

	-- Drag for objects window
	local objDragging = false
	local objDragStart, objStartPos
	local objInputChangedConn, objInputEndedConn
	local function onObjDragStart(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 then
			objDragging = true
			objDragStart = inp.Position
			objStartPos = objMain.Position
		end
	end
	objTop.InputBegan:Connect(onObjDragStart)
	objTitle.InputBegan:Connect(onObjDragStart)
	objMain.InputBegan:Connect(onObjDragStart)
	objInputChangedConn = UserInputService.InputChanged:Connect(function(inp)
		if objDragging and inp.UserInputType == Enum.UserInputType.MouseMovement then
			local delta = inp.Position - objDragStart
			objMain.Position = UDim2.new(objStartPos.X.Scale, objStartPos.X.Offset + delta.X, objStartPos.Y.Scale, objStartPos.Y.Offset + delta.Y)
		end
	end)
	objInputEndedConn = UserInputService.InputEnded:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 then
			objDragging = false
		end
	end)

	objCloseBtn.MouseButton1Click:Connect(function()
		if objInputChangedConn then objInputChangedConn:Disconnect() end
		if objInputEndedConn then objInputEndedConn:Disconnect() end
		objScreen:Destroy()
	end)

	-- List remotes button (prints to Output so you can set TAKE_REMOTE_PATH)
	local objRemotesBtn = Instance.new("TextButton")
	objRemotesBtn.Name = "Remotes"
	objRemotesBtn.Size = UDim2.new(0, 58, 0, 28)
	objRemotesBtn.Position = UDim2.new(1, -250, 0, 0)
	objRemotesBtn.BackgroundTransparency = 1
	objRemotesBtn.Text = "Remotes"
	objRemotesBtn.TextColor3 = Color3.fromRGB(180, 200, 255)
	objRemotesBtn.TextSize = 11
	objRemotesBtn.Font = Enum.Font.Gotham
	objRemotesBtn.Parent = objTop

	-- Refresh button (manual refresh only)
	local objRefreshBtn = Instance.new("TextButton")
	objRefreshBtn.Name = "Refresh"
	objRefreshBtn.Size = UDim2.new(0, 56, 0, 28)
	objRefreshBtn.Position = UDim2.new(1, -168, 0, 0)
	objRefreshBtn.BackgroundTransparency = 1
	objRefreshBtn.Text = "Refresh"
	objRefreshBtn.TextColor3 = Color3.fromRGB(200, 230, 255)
	objRefreshBtn.TextSize = 12
	objRefreshBtn.Font = Enum.Font.Gotham
	objRefreshBtn.Parent = objTop

	-- Teleport to top Bubu button
	local objTeleportBtn = Instance.new("TextButton")
	objTeleportBtn.Name = "Teleport"
	objTeleportBtn.Size = UDim2.new(0, 70, 0, 28)
	objTeleportBtn.Position = UDim2.new(1, -106, 0, 0)
	objTeleportBtn.BackgroundTransparency = 1
	objTeleportBtn.Text = "Go to top"
	objTeleportBtn.TextColor3 = Color3.fromRGB(200, 230, 255)
	objTeleportBtn.TextSize = 11
	objTeleportBtn.Font = Enum.Font.Gotham
	objTeleportBtn.Parent = objTop

	-- Scrollable list (full width)
	local scroll = Instance.new("ScrollingFrame")
	scroll.Name = "List"
	scroll.Size = UDim2.new(1, -16, 1, -44)
	scroll.Position = UDim2.new(0, 8, 0, 36)
	scroll.BackgroundColor3 = Color3.fromRGB(25, 35, 55)
	scroll.BorderSizePixel = 0
	scroll.ScrollBarThickness = 6
	scroll.ScrollBarImageColor3 = Color3.fromRGB(90, 170, 255)
	scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scroll.Parent = objMain

	local scrollCorner = Instance.new("UICorner")
	scrollCorner.CornerRadius = UDim.new(0, 6)
	scrollCorner.Parent = scroll

	local listLayout = Instance.new("UIListLayout")
	listLayout.Padding = UDim.new(0, 2)
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Parent = scroll

	local workspace = game:GetService("Workspace")
	local ROW_HEIGHT = 22

	-- Rarity sort order: rarest (1) to most common (9). Lower number = higher in list.
	local RARITY_ORDER = {
		Exclusive = 1, Secret = 2, God = 3, Mythic = 4, Legendary = 5,
		Epic = 6, Rare = 7, Uncommon = 8, Common = 9
	}
	local function raritySortKey(rarityStr)
		if not rarityStr or rarityStr == "" then return 99 end
		local key = RARITY_ORDER[rarityStr]
		return key or 99
	end

	-- Get text from CharacterInfo BillboardGui label by name (e.g. "Rarity", "Income", "CharTime")
	local function getCharacterInfoLabel(model, labelName)
		for _, desc in ipairs(model:GetDescendants()) do
			if desc:IsA("BillboardGui") and desc.Name == "CharacterInfo" then
				local lbl = desc:FindFirstChild(labelName, true)
				if lbl and (lbl:IsA("TextLabel") or lbl:IsA("TextButton")) and lbl.Text then
					return lbl.Text
				end
				break
			end
		end
		local charInfo = model:FindFirstChild("CharacterInfo", true)
		if charInfo then
			local gui = charInfo:IsA("BillboardGui") and charInfo or charInfo:FindFirstChildOfClass("BillboardGui")
			if gui then
				local lbl = gui:FindFirstChild(labelName, true)
				if lbl and (lbl:IsA("TextLabel") or lbl:IsA("TextButton")) and lbl.Text then
					return lbl.Text
				end
			end
		end
		return nil
	end

	-- List row: NPCId - Mutation - Rarity - Income - CharTime (no click needed to see info)
	local function getNPCDisplayLabel(model)
		local npcId = tostring(model:GetAttribute("NPCId") or "?")
		local mutation = tostring(model:GetAttribute("Mutation") or "?")
		local rarity = getCharacterInfoLabel(model, "Rarity") or "?"
		local income = getCharacterInfoLabel(model, "Income") or "?"
		local charTime = getCharacterInfoLabel(model, "CharTime") or "?"
		return npcId .. " - " .. mutation .. " - " .. rarity .. " - " .. income .. " - " .. charTime
	end

	local function addRow(model, layoutOrder)
		local row = Instance.new("TextButton")
		row.Name = model.Name
		row.Size = UDim2.new(1, -8, 0, ROW_HEIGHT)
		row.BackgroundColor3 = Color3.fromRGB(35, 50, 75)
		row.BorderSizePixel = 0
		row.LayoutOrder = layoutOrder
		row.Text = ""
		row.AutoButtonColor = true
		row.Parent = scroll
		local rowCorner = Instance.new("UICorner")
		rowCorner.CornerRadius = UDim.new(0, 4)
		rowCorner.Parent = row
		local lbl = Instance.new("TextLabel")
		lbl.Size = UDim2.new(1, -8, 1, -4)
		lbl.Position = UDim2.new(0, 6, 0, 2)
		lbl.BackgroundTransparency = 1
		lbl.Text = getNPCDisplayLabel(model)
		lbl.TextColor3 = Color3.fromRGB(200, 220, 255)
		lbl.TextSize = 11
		lbl.Font = Enum.Font.Gotham
		lbl.TextXAlignment = Enum.TextXAlignment.Left
		lbl.TextTruncate = Enum.TextTruncate.AtEnd
		lbl.Parent = row
		return row
	end

	-- Returns sorted list of Bubus (same order as list: rarest first)
	local function getSortedBubuList()
		local collected = {}
		local prefix = OBJECTS_LIST_PARENT_FILTER
		for _, obj in ipairs(workspace:GetDescendants()) do
			if obj.ClassName == "Model" then
				local fullName = obj:GetFullName()
				local parentMatch = not prefix or prefix == ""
					or (fullName == prefix or string.sub(fullName, 1, #prefix + 1) == prefix .. ".")
				if parentMatch then
					local mutation = obj:GetAttribute("Mutation")
					if mutation ~= nil and mutation ~= "Normal" then
						table.insert(collected, obj)
					end
				end
			end
		end
		table.sort(collected, function(a, b)
			local rarityA = getCharacterInfoLabel(a, "Rarity")
			local rarityB = getCharacterInfoLabel(b, "Rarity")
			return raritySortKey(rarityA) < raritySortKey(rarityB)
		end)
		return collected
	end

	local function teleportToTopBubu()
		local character = LocalPlayer.Character
		if not character then return end
		local root = character:FindFirstChild("HumanoidRootPart")
		if not root then return end
		local sorted = getSortedBubuList()
		if #sorted == 0 then return end
		local topModel = sorted[1]
		local pos
		local ok, pivot = pcall(function() return topModel:GetPivot() end)
		if ok and pivot then
			pos = pivot.Position
		elseif topModel.PrimaryPart then
			pos = topModel.PrimaryPart.Position
		else
			return
		end
		-- Teleport 4 studs in front of the Bubu so player doesn't spawn inside it
		root.CFrame = CFrame.new(pos + Vector3.new(0, 0, 4))
	end

	local function refreshList()
		for _, child in ipairs(scroll:GetChildren()) do
			if child ~= listLayout then
				child:Destroy()
			end
		end
		local collected = getSortedBubuList()
		for i, model in ipairs(collected) do
			addRow(model, i)
		end
	end

	refreshList()

	objRemotesBtn.MouseButton1Click:Connect(function()
		listAllRemotes()
	end)
	objRefreshBtn.MouseButton1Click:Connect(refreshList)
	-- Go to top: script handles teleport to top Bubu + 2 sec wait + take Bubu + teleport outside (no E key)
	objTeleportBtn.MouseButton1Click:Connect(function()
		goToTopThenTakeAndTeleportOutside()
	end)

	-- Auto-refresh list every 2 seconds while window is open
	task.spawn(function()
		while objScreen.Parent do
			task.wait(2)
			if not objScreen.Parent then break end
			refreshList()
		end
	end)
end

objectsBtn.MouseButton1Click:Connect(openObjectsWindow)

-- Collect All Cash: call ReplicatedStorage.CollectAllCash (RemoteEvent or RemoteFunction)
collectCashBtn.MouseButton1Click:Connect(function()
	local collectAllCash = ReplicatedStorage:FindFirstChild("CollectAllCash")
	if not collectAllCash then
		warn("[CollectAllCash] ReplicatedStorage.CollectAllCash not found")
		return
	end
	local ok, err = pcall(function()
		if collectAllCash:IsA("RemoteEvent") then
			collectAllCash:FireServer()
		elseif collectAllCash:IsA("RemoteFunction") then
			collectAllCash:InvokeServer()
		else
			warn("[CollectAllCash] CollectAllCash is not a RemoteEvent or RemoteFunction")
		end
	end)
	if not ok then
		warn("[CollectAllCash] Error:", err)
	end
end)

goToTopBtn.MouseButton1Click:Connect(function()
	goToTopThenTakeAndTeleportOutside()
end)

startCollectBtn.MouseButton1Click:Connect(function()
	if collectingActive then return end
	collectingActive = true
	task.spawn(runCollectingLoop)
end)

stopCollectBtn.MouseButton1Click:Connect(function()
	collectingActive = false
end)

teleportBackBtn.MouseButton1Click:Connect(function()
	local character = LocalPlayer.Character
	if not character then return end
	local root = character:FindFirstChild("HumanoidRootPart")
	if root then
		root.CFrame = CFrame.new(OUTSIDE_FIELD_POSITION)
	end
end)

-- Current speed value (0–1)
local speedNorm = (DEFAULT_WALK_SPEED - MIN_WALK_SPEED) / (MAX_WALK_SPEED - MIN_WALK_SPEED)

local function speedFromNorm(norm)
	norm = math.clamp(norm, 0, 1)
	return math.floor(MIN_WALK_SPEED + (MAX_WALK_SPEED - MIN_WALK_SPEED) * norm + 0.5)
end

local function normFromSpeed(speed)
	return (math.clamp(speed, MIN_WALK_SPEED, MAX_WALK_SPEED) - MIN_WALK_SPEED) / (MAX_WALK_SPEED - MIN_WALK_SPEED)
end

local function applySpeedToCharacter(speed)
	local character = LocalPlayer.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.WalkSpeed = speed
		end
	end
end

local function setSpeedFromNorm(norm)
	norm = math.clamp(norm, 0, 1)
	speedNorm = norm
	local speed = speedFromNorm(norm)
	speedValueLabel.Text = tostring(speed)
	sliderFill.Size = UDim2.new(norm, 0, 1, 0)
	sliderThumb.Position = UDim2.new(norm, -7, 0.5, -7)
	applySpeedToCharacter(speed)
end

local function updateSliderFromMouse(x)
	local trackAbs = sliderTrack.AbsolutePosition.X
	local trackSize = sliderTrack.AbsoluteSize.X
	local rel = (x - trackAbs) / math.max(trackSize, 1)
	setSpeedFromNorm(rel)
end

-- Slider drag state
local sliderDragging = false
local sliderInputConnection

local function beginSliderDrag()
	sliderDragging = true
	sliderInputConnection = UserInputService.InputChanged:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseMovement then
			-- Only update slider when mouse is over the track
			local trackPos = sliderTrack.AbsolutePosition
			local trackSize = sliderTrack.AbsoluteSize
			local x, y = inp.Position.X, inp.Position.Y
			if x >= trackPos.X and x <= trackPos.X + trackSize.X and y >= trackPos.Y and y <= trackPos.Y + trackSize.Y then
				updateSliderFromMouse(x)
			end
		end
	end)
	local endConn
	endConn = UserInputService.InputEnded:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 then
			sliderDragging = false
			if sliderInputConnection then sliderInputConnection:Disconnect() end
			endConn:Disconnect()
		end
	end)
end

sliderTrack.InputBegan:Connect(function(inp)
	if inp.UserInputType == Enum.UserInputType.MouseButton1 then
		updateSliderFromMouse(inp.Position.X)
		beginSliderDrag()
	end
end)

sliderThumb.InputBegan:Connect(function(inp)
	if inp.UserInputType == Enum.UserInputType.MouseButton1 then
		beginSliderDrag()
	end
end)

-- Initialize slider position and apply default speed
setSpeedFromNorm(speedNorm)

-- Apply speed when character spawns/respawns
LocalPlayer.CharacterAdded:Connect(function(character)
	local humanoid = character:WaitForChild("Humanoid", 5)
	if humanoid then
		humanoid.WalkSpeed = speedFromNorm(speedNorm)
	end
end)

-- If character already exists, set WalkSpeed once
if LocalPlayer.Character then
	applySpeedToCharacter(speedFromNorm(speedNorm))
end

print("Player name:", getPlayerName())
