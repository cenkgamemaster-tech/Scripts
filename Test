--[[
	Test script for Roblox game.
	Small UI that gets the local player and displays the player's name.
	Reference: Roblox/Referrence/JunkieKeySystem Example.lua
]]

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Remove any existing UI so we don't stack
local existing = PlayerGui:FindFirstChild("PlayerNameTest")
if existing then
	existing:Destroy()
end

-- Test: get player name
local function getPlayerName()
	return LocalPlayer.Name or "Unknown"
end

-- Build small UI
local screen = Instance.new("ScreenGui")
screen.Name = "PlayerNameTest"
screen.ResetOnSpawn = false
screen.Parent = PlayerGui

-- Speed slider range (Roblox default WalkSpeed is 16)
local MIN_WALK_SPEED = 8
local MAX_WALK_SPEED = 300
local DEFAULT_WALK_SPEED = 16

-- Objects list: only show instances whose Name contains any of these (case-insensitive)
local OBJECTS_LIST_NAME_FILTERS = { "Bubu", "Toffee", "Noob" }
-- Objects list: only show models whose FullName starts with this path (e.g. Workspace.Map.Zones.Field includes Field and all descendants); set to nil or "" to skip
local OBJECTS_LIST_PARENT_FILTER = "Workspace.Map.Zones.Field.NPC"

-- Take Bubu with E: max distance to consider "near" the player (studs)
local TAKE_BUBU_MAX_RANGE = 30
-- First teleport after taking Bubu; then step teleport (Z only) until Z = -30, then MoveTo to Z = -10 (X,Y unchanged)
local TELEPORT_FIRST_EXIT = Vector3.new(-35, 4.2, -31)
-- Step teleport back: change only Z until we reach this (then MoveTo from here to Z = -10)
local TELEPORT_BACK_Z_END = -30
local TELEPORT_BACK_Z_STEP = 10
-- MoveTo goes to (same X, same Y, -10). "Teleport back" button uses this.
local OUTSIDE_FIELD_POSITION = Vector3.new(-22, 4.2, -10)
-- MoveTo to outside: max time (s) per attempt (character may stop moving after ~30s while carrying)
local WALK_TO_OUTSIDE_TIMEOUT = 30
local WALK_ARRIVED_DISTANCE = 4
-- When carrying: after first stuck, press and hold S until destination (no MoveTo re-trigger)
local Z_STUCK_THRESHOLD = 0.5
local Z_STUCK_TIME = 2
-- Simulate hold E for pickup: duration in seconds (short = start moving sooner; increase if pickup doesn't register)
local HOLD_E_DURATION = 0.6
-- Optional: set to a path string (e.g. "ReplicatedStorage.Remotes.Field.PickupNPCStateChanged") to use that remote; nil = auto-detect
local TAKE_REMOTE_PATH = nil
-- Known pickup remotes (tried in order when TAKE_REMOTE_PATH is nil)
local TAKE_REMOTE_CANDIDATES = {
	"ReplicatedStorage.Remotes.Field.PickupNPCStateChanged",
	"ReplicatedStorage.Remotes.Plot.PickupSlotNPC",
}
-- Drop NPC remote (used on 30s timeout: drop then grab again instead of teleporting)
local DROP_NPC_REMOTE_PATH = "ReplicatedStorage.Remotes.Field.DropNPC"
local FUSE_REMOTE_PATH = "ReplicatedStorage.Remotes.Fuse"

local workspace = game:GetService("Workspace")

-- Simulate press and hold E for a duration (for pickup). Uses VirtualInputManager if available.
local function holdEKey(durationSeconds)
	durationSeconds = durationSeconds or HOLD_E_DURATION
	local ok, vim = pcall(function() return game:GetService("VirtualInputManager") end)
	if ok and vim and vim.SendKeyEvent then
		vim:SendKeyEvent(true, Enum.KeyCode.E, false, game)
		task.wait(durationSeconds)
		vim:SendKeyEvent(false, Enum.KeyCode.E, false, game)
		return true
	end
	task.wait(durationSeconds)
	return false
end

-- Press S down or release S up (for holding S until destination after first stuck). Uses VirtualInputManager.
local function pressSDown()
	local ok, vim = pcall(function() return game:GetService("VirtualInputManager") end)
	if ok and vim and vim.SendKeyEvent then
		vim:SendKeyEvent(true, Enum.KeyCode.S, false, game)
		return true
	end
	return false
end
local function releaseSUp()
	local ok, vim = pcall(function() return game:GetService("VirtualInputManager") end)
	if ok and vim and vim.SendKeyEvent then
		vim:SendKeyEvent(false, Enum.KeyCode.S, false, game)
		return true
	end
	return false
end

-- Get all Bubu models (path match; include if Mutation ~= Normal, or if Mutation is Normal but Rarity is Secret/Exclusive)
local function getCharacterInfoLabelTopLevel(model, labelName)
	for _, desc in ipairs(model:GetDescendants()) do
		if desc:IsA("BillboardGui") and desc.Name == "CharacterInfo" then
			local lbl = desc:FindFirstChild(labelName, true)
			if lbl and (lbl:IsA("TextLabel") or lbl:IsA("TextButton")) and lbl.Text then
				return lbl.Text
			end
			break
		end
	end
	local charInfo = model:FindFirstChild("CharacterInfo", true)
	if charInfo then
		local gui = charInfo:IsA("BillboardGui") and charInfo or charInfo:FindFirstChildOfClass("BillboardGui")
		if gui then
			local lbl = gui:FindFirstChild(labelName, true)
			if lbl and (lbl:IsA("TextLabel") or lbl:IsA("TextButton")) and lbl.Text then
				return lbl.Text
			end
		end
	end
	return nil
end

local function getBubuModels()
	local collected = {}
	local prefix = OBJECTS_LIST_PARENT_FILTER
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj.ClassName == "Model" then
			local fullName = obj:GetFullName()
			local parentMatch = not prefix or prefix == ""
				or (fullName == prefix or string.sub(fullName, 1, #prefix + 1) == prefix .. ".")
			if parentMatch then
				local mutation = obj:GetAttribute("Mutation")
				if mutation ~= nil then
					local rarity = getCharacterInfoLabelTopLevel(obj, "Rarity")
					local includeByMutation = (mutation ~= "Normal")
						or (mutation == "Normal" and (rarity == "Secret" or rarity == "Exclusive"))
					if includeByMutation then
						local excludeGoldDiamondLowRarity = (mutation == "Gold" or mutation == "Diamond")
							and (rarity == "Common" or rarity == "Uncommon" or rarity == "Rare")
						if not excludeGoldDiamondLowRarity then
							table.insert(collected, obj)
						end
					end
				end
			end
		end
	end
	return collected
end

-- Rarity sort (same as list: rarest first). Used for "Go to top" and E-hold teleport.
local RARITY_ORDER = {
	Exclusive = 1, Secret = 2, God = 3, Mythic = 4, Legendary = 5,
	Epic = 6, Rare = 7, Uncommon = 8, Common = 9
}
local function raritySortKey(rarityStr)
	if not rarityStr or rarityStr == "" then return 99 end
	return RARITY_ORDER[rarityStr] or 99
end
local function getSortedBubuListTopLevel()
	local collected = getBubuModels()
	table.sort(collected, function(a, b)
		return raritySortKey(getCharacterInfoLabelTopLevel(a, "Rarity")) < raritySortKey(getCharacterInfoLabelTopLevel(b, "Rarity"))
	end)
	return collected
end
-- Position of top Bubu (rarest), 4 studs in front; same as "Go to top" button. Returns nil if no Bubus.
local function getTopBubuPosition()
	local sorted = getSortedBubuListTopLevel()
	if #sorted == 0 then return nil end
	local topModel = sorted[1]
	local ok, pivot = pcall(function() return topModel:GetPivot() end)
	if ok and pivot then
		return pivot.Position + Vector3.new(0, 0, 4)
	end
	if topModel.PrimaryPart then
		return topModel.PrimaryPart.Position + Vector3.new(0, 0, 4)
	end
	return nil
end

local function resolveRemotePath(pathString)
	local node = game
	for part in string.gmatch(pathString, "[^.]+") do
		node = node:FindFirstChild(part)
		if not node then return nil end
	end
	if node:IsA("RemoteEvent") or node:IsA("RemoteFunction") then return node end
	return nil
end

-- Hook Fuse remote to log what the server sends (Output when you select NPCs or fuse)
do
	local fuseRemote = resolveRemotePath(FUSE_REMOTE_PATH)
	if fuseRemote and fuseRemote:IsA("RemoteEvent") then
		fuseRemote.OnClientEvent:Connect(function(...)
			local args = { ... }
			local parts = {}
			for i, v in ipairs(args) do table.insert(parts, tostring(v)) end
			print("[Fuse] OnClientEvent args:", table.concat(parts, ", "))
		end)
	end
end

-- Find a remote that might be the game's "take/capture" API. Tries TAKE_REMOTE_PATH, then TAKE_REMOTE_CANDIDATES, then name scan.
local function findTakeRemote()
	if type(TAKE_REMOTE_PATH) == "string" and TAKE_REMOTE_PATH ~= "" then
		local r = resolveRemotePath(TAKE_REMOTE_PATH)
		if r then return r end
	end
	for _, path in ipairs(TAKE_REMOTE_CANDIDATES or {}) do
		local r = resolveRemotePath(path)
		if r then return r end
	end
	local keywords = { "take", "capture", "pick", "collect", "catch", "bubu", "pet", "npc", "add", "pickup" }
	local function nameMatches(name)
		local lower = string.lower(name or "")
		for _, kw in ipairs(keywords) do
			if string.find(lower, kw) then return true end
		end
		return false
	end
	for _, child in ipairs(ReplicatedStorage:GetDescendants()) do
		if (child:IsA("RemoteEvent") or child:IsA("RemoteFunction")) and nameMatches(child.Name) then
			return child
		end
	end
	for _, child in ipairs(ReplicatedStorage:GetChildren()) do
		if (child:IsA("RemoteEvent") or child:IsA("RemoteFunction")) and nameMatches(child.Name) then
			return child
		end
	end
	return nil
end

-- Try to take the Bubu via the game's remote. For PickupNPCStateChanged, mimics "hold E 2 sec": fire true, wait 2, fire false.
local function tryTakeViaRemote(nearest)
	local remote = findTakeRemote()
	if not remote then
		print("[Take] No take remote found. Set TAKE_REMOTE_PATH at top of script if you know the path.")
		return false
	end
	local id = nearest:GetAttribute("NPCId") or nearest:GetAttribute("NpcId") or nearest.Name
	local fullName = remote:GetFullName()
	local isStateChanged = string.find(fullName, "PickupNPCStateChanged")

	local function fireRemote(...)
		local a = { ... }
		if remote:IsA("RemoteEvent") then
			remote:FireServer(table.unpack(a))
		else
			remote:InvokeServer(table.unpack(a))
		end
	end

	-- If this is the "state changed" remote: only fire (pickTarget, true) and wait 2s. Do NOT fire false here –
	-- we release after teleport + walk so the Bubu doesn’t drop in the field. Call releasePickupState(nearest) after arriving.
	if isStateChanged then
		local function tryStartPickup(pickTarget)
			return pcall(function() fireRemote(pickTarget, true) end)
		end
		if tryStartPickup(nearest) then
			print("[Take] Called PickupNPCStateChanged(nearest, true). Step teleport then MoveTo.")
			return true
		end
		if tryStartPickup(id) then
			print("[Take] Called PickupNPCStateChanged(id, true). Step teleport then MoveTo.")
			return true
		end
		if tryStartPickup(nearest.Name) then
			print("[Take] Called PickupNPCStateChanged(nearest.Name, true). Step teleport then MoveTo.")
			return true
		end
		if pcall(function() fireRemote(true) end) then
			print("[Take] Called PickupNPCStateChanged true. Step teleport then MoveTo.")
			return true
		end
	end

	-- Otherwise try common argument patterns
	local argsList = {
		{ true },
		{ nearest, true },
		{ true, nearest },
		{ nearest },
		{ nearest.Name },
		{ id },
		{ id, nearest },
		{ nearest, LocalPlayer },
		{ 1, nearest },
		{ 1, id },
	}
	for _, args in ipairs(argsList) do
		local ok, err = pcall(function() fireRemote(table.unpack(args)) end)
		if ok then
			print("[Take] Called remote:", fullName, "with args count:", #args)
			return true
		end
	end
	print("[Take] Remote", fullName, "failed all argument patterns. Try setting TAKE_REMOTE_PATH and correct args.")
	return false
end

-- Release pickup state after we’ve teleported and walked outside (so Bubu doesn’t drop in the field).
-- Call DropNPC remote to drop the held NPC (used when we retry: drop then hold E again).
local function dropNPC(nearest)
	if not nearest or not nearest.Parent then return end
	local remote = resolveRemotePath(DROP_NPC_REMOTE_PATH)
	if not remote then return end
	local id = nearest:GetAttribute("NPCId") or nearest:GetAttribute("NpcId") or nearest.Name
	local function fire(...)
		if remote:IsA("RemoteEvent") then remote:FireServer(...) else remote:InvokeServer(...) end
	end
	pcall(function() fire(nearest) end)
	pcall(function() fire(id) end)
	pcall(function() fire(nearest.Name) end)
end

-- Release pickup state after we've teleported and walked outside (so Bubu doesn't drop in the field).
local function releasePickupState(nearest)
	if not nearest or not nearest.Parent then return end
	local remote = findTakeRemote()
	if not remote then return end
	local fullName = remote:GetFullName()
	if not string.find(fullName, "PickupNPCStateChanged") then return end
	local id = nearest:GetAttribute("NPCId") or nearest:GetAttribute("NpcId") or nearest.Name
	local function fire(...)
		if remote:IsA("RemoteEvent") then remote:FireServer(...) else remote:InvokeServer(...) end
	end
	pcall(function() fire(nearest, false) end)
	pcall(function() fire(id, false) end)
	pcall(function() fire(false) end)
end

-- Print all RemoteEvents/RemoteFunctions under ReplicatedStorage to Output (use "List remotes" button or call once).
local function listAllRemotes()
	local list = {}
	for _, child in ipairs(ReplicatedStorage:GetDescendants()) do
		if child:IsA("RemoteEvent") or child:IsA("RemoteFunction") then
			table.insert(list, child:GetFullName())
		end
	end
	table.sort(list)
	print("---- ReplicatedStorage remotes (set TAKE_REMOTE_PATH to one of these if you find the take/capture one) ----")
	for _, path in ipairs(list) do
		print("  ", path)
	end
	print("---- Total:", #list, "remotes ----")
	return list
end

-- Traverse game at runtime and list objects; optional nameFilter (e.g. "Fuse") to only include instances whose Name or FullName contains it (case-insensitive).
-- Prints to Output so you can copy the list when running remotely.
local function listObjectsInGame(nameFilter)
	local filter = (type(nameFilter) == "string" and nameFilter ~= "") and nameFilter:lower() or nil
	local function matches(inst)
		if not filter then return true end
		local name = (inst.Name or ""):lower()
		local full = (inst:GetFullName() or ""):lower()
		return name:find(filter, 1, true) or full:find(filter, 1, true)
	end
	local list = {}
	local function scan(parent)
		for _, child in ipairs(parent:GetChildren()) do
			if matches(child) then
				table.insert(list, child:GetFullName())
			end
			scan(child)
		end
	end
	local services = { Workspace, PlayerGui, ReplicatedStorage }
	for _, service in ipairs(services) do
		pcall(function()
			if matches(service) then
				table.insert(list, service:GetFullName())
			end
			scan(service)
		end)
	end
	table.sort(list)
	local title = filter and ("---- Objects containing \"" .. nameFilter .. "\" ----") or "---- All objects (Workspace, PlayerGui, ReplicatedStorage) ----"
	print(title)
	for _, path in ipairs(list) do
		print("  ", path)
	end
	print("---- Total:", #list, "entries ----")
	return list
end

-- Read content from MainUI.Menus.FuseFrame: PossibleFrame (possible NPCs) and BringFrame (selected NPCs to fuse).
-- Path: PlayerGui.MainUI.Menus.FuseFrame.Frame.PossibleFrame (FrameTemplate: NpcName, Mutation, Rarity, Chance)
--       PlayerGui.MainUI.Menus.FuseFrame.Frame.BringFrame (ButtonTemplate clones: NpcName, Mutation, Rarity)
local function readFuseFrameContent()
	local gui = LocalPlayer:FindFirstChild("PlayerGui")
	if not gui then return "PlayerGui not found." end
	local mainUI = gui:FindFirstChild("MainUI")
	if not mainUI then return "MainUI not found." end
	local menus = mainUI:FindFirstChild("Menus")
	if not menus then return "MainUI.Menus not found." end
	local fuseFrame = menus:FindFirstChild("FuseFrame")
	if not fuseFrame then return "MainUI.Menus.FuseFrame not found. Open the Fuse menu in-game first." end
	local frame = fuseFrame:FindFirstChild("Frame")
	if not frame then return "FuseFrame.Frame not found." end

	local function readRow(parent, labelNames)
		local labels = {}
		for _, name in ipairs(labelNames) do
			local el = parent:FindFirstChild(name)
			labels[name] = (el and el:IsA("GuiObject") and el.Text) and el.Text or ""
		end
		return labels
	end

	local function formatRow(labels, order)
		order = order or { "NpcName", "Mutation", "Rarity", "Chance" }
		local parts = {}
		for _, k in ipairs(order) do
			if labels[k] and labels[k] ~= "" then
				table.insert(parts, labels[k])
			end
		end
		return table.concat(parts, " | ")
	end

	local out = {}

	-- PossibleFrame = possible NPCs (e.g. 3 options)
	local possibleFrame = frame:FindFirstChild("PossibleFrame")
	if possibleFrame then
		table.insert(out, "=== Possible NPCs (PossibleFrame) ===")
		local count = 0
		for _, child in ipairs(possibleFrame:GetChildren()) do
			local npcName = child:FindFirstChild("NpcName")
			if npcName and (npcName:IsA("TextLabel") or npcName:IsA("TextButton")) then
				count = count + 1
				local labels = readRow(child, { "NpcName", "Mutation", "Rarity", "Chance" })
				table.insert(out, ("  %d. %s"):format(count, formatRow(labels)))
			end
		end
		if count == 0 then
			table.insert(out, "  (no FrameTemplate rows with NpcName found)")
		end
		table.insert(out, "")
	end

	-- BringFrame = NPCs you're bringing to fuse (e.g. 4 slots)
	local bringFrame = frame:FindFirstChild("BringFrame")
	if bringFrame then
		table.insert(out, "=== Bring (selected for fuse) ===")
		local count = 0
		for _, child in ipairs(bringFrame:GetChildren()) do
			local npcName = child:FindFirstChild("NpcName")
			if npcName and (npcName:IsA("TextLabel") or npcName:IsA("TextButton")) then
				count = count + 1
				local labels = readRow(child, { "NpcName", "Mutation", "Rarity" })
				table.insert(out, ("  %d. %s"):format(count, formatRow(labels, { "NpcName", "Mutation", "Rarity" })))
			end
		end
		if count == 0 then
			table.insert(out, "  (no button rows with NpcName found)")
		end
	end

	return table.concat(out, "\n")
end

-- Serialize a table to a readable string (depth-limited). For reading fuse data from ModuleScripts.
local function tableToString(t, depth, maxDepth)
	depth = depth or 0
	maxDepth = maxDepth or 4
	if depth > maxDepth then return "(max depth)" end
	if type(t) ~= "table" then return tostring(t) end
	local lines = {}
	for k, v in pairs(t) do
		local keyStr = type(k) == "string" and k or "[" .. tostring(k) .. "]"
		if type(v) == "table" then
			table.insert(lines, ("%s%s = { %s }"):format(string.rep("  ", depth), keyStr, tableToString(v, depth + 1, maxDepth)))
		else
			table.insert(lines, ("%s%s = %s"):format(string.rep("  ", depth), keyStr, tostring(v)))
		end
	end
	return table.concat(lines, "\n")
end

-- Search the client for a fuse list / possible-options data (ModuleScripts, ReplicatedStorage, FuseFrame attributes).
local function findFuseDataOnClient()
	local out = {}

	-- 1) ReplicatedStorage: ModuleScripts with "Fuse" in name; require and dump if they return a table
	table.insert(out, "=== ReplicatedStorage ModuleScripts (name contains Fuse) ===")
	for _, desc in ipairs(ReplicatedStorage:GetDescendants()) do
		if desc:IsA("ModuleScript") and string.find(desc.Name:lower(), "fuse") then
			local ok, result = pcall(function() return require(desc) end)
			if ok and type(result) == "table" then
				local keyCount = 0
				for _ in pairs(result) do keyCount = keyCount + 1 end
				table.insert(out, "")
				table.insert(out, ("[%s] (table, %d keys):"):format(desc:GetFullName(), keyCount))
				local preview = tableToString(result, 0, 3)
				if #preview > 4000 then preview = preview:sub(1, 4000) .. "\n... (truncated)" end
				table.insert(out, preview)
			elseif ok then
				table.insert(out, ("[%s] => %s"):format(desc:GetFullName(), tostring(result)))
			else
				table.insert(out, ("[%s] require error: %s"):format(desc:GetFullName(), tostring(result)))
			end
		end
	end
	table.insert(out, "")

	-- 2) Look for likely data container names under ReplicatedStorage and PlayerGui
	local dataNames = { "FuseData", "FuseRecipes", "FuseTable", "Combinations", "PossibleOptions", "FuseOptions", "Recipes", "Fuse" }
	table.insert(out, "=== Instances named like FuseData / Combinations (paths and children) ===")
	for _, parent in ipairs({ ReplicatedStorage, PlayerGui }) do
		for _, name in ipairs(dataNames) do
			local node = parent:FindFirstChild(name)
			if node then
				table.insert(out, ("%s (ClassName=%s)"):format(node:GetFullName(), node.ClassName))
				for _, child in ipairs(node:GetChildren()) do
					table.insert(out, ("  - %s (%s)"):format(child.Name, child.ClassName))
					if child:IsA("ModuleScript") then
						local ok, result = pcall(function() return require(child) end)
						if ok and type(result) == "table" then
							local preview = tableToString(result, 0, 2)
							if #preview > 2000 then preview = preview:sub(1, 2000) .. "\n... (truncated)" end
							table.insert(out, "    require() => " .. preview:gsub("\n", "\n    "))
						end
					end
				end
			end
		end
	end
	table.insert(out, "")

	-- 3) FuseFrame and its Frame: attributes and any Data/List child
	table.insert(out, "=== FuseFrame / Frame (attributes and data-like children) ===")
	local gui = LocalPlayer:FindFirstChild("PlayerGui")
	if gui then
		local mainUI = gui:FindFirstChild("MainUI")
		if mainUI then
			local menus = mainUI:FindFirstChild("Menus")
			if menus then
				local fuseFrame = menus:FindFirstChild("FuseFrame")
				if fuseFrame then
					for _, attrName in ipairs(fuseFrame:GetAttributeNames()) do
						table.insert(out, ("FuseFrame attribute: %s = %s"):format(attrName, tostring(fuseFrame:GetAttribute(attrName))))
					end
					local frame = fuseFrame:FindFirstChild("Frame")
					if frame then
						for _, attrName in ipairs(frame:GetAttributeNames()) do
							table.insert(out, ("FuseFrame.Frame attribute: %s = %s"):format(attrName, tostring(frame:GetAttribute(attrName))))
						end
						for _, child in ipairs(frame:GetChildren()) do
							if string.find(child.Name:lower(), "data") or string.find(child.Name:lower(), "list") or child.ClassName == "Folder" then
								table.insert(out, ("  Child: %s (%s), %d children"):format(child.Name, child.ClassName, #child:GetChildren()))
							end
						end
					end
				else
					table.insert(out, "FuseFrame not found (open Fuse menu first).")
				end
			end
		end
	end
	table.insert(out, "")
	table.insert(out, "--- End of Fuse data search ---")
	return table.concat(out, "\n")
end

-- Walk character to target position (Humanoid:MoveTo). Returns true if arrived within distance, false if timed out or no character.
local function walkToPosition(character, targetPos, timeoutSeconds, arrivedDist)
	local humanoid = character and character:FindFirstChildOfClass("Humanoid")
	local root = character and character:FindFirstChild("HumanoidRootPart")
	if not humanoid or not root then return false end
	timeoutSeconds = timeoutSeconds or WALK_TO_OUTSIDE_TIMEOUT
	arrivedDist = arrivedDist or WALK_ARRIVED_DISTANCE
	humanoid:MoveTo(targetPos)
	local start = os.clock()
	while (root.Position - targetPos).Magnitude > arrivedDist and (os.clock() - start) < timeoutSeconds do
		humanoid:MoveTo(targetPos)
		task.wait(0.2)
	end
	local arrived = (root.Position - targetPos).Magnitude <= arrivedDist
	if (root.Position - targetPos).Magnitude <= arrivedDist * 2 then
		root.CFrame = CFrame.new(targetPos)
	end
	return arrived
end

-- Take nearest Bubu and teleport (player + Bubu) to outside the field. Optional onArrived() called when MoveTo finishes.
-- After hold E: move to destination; if character Z stops changing (stuck), re-trigger MoveTo(destination) until we arrive.
local function takeNearestBubuAndTeleportOutside(onArrived)
	local character = LocalPlayer.Character
	if not character then return end
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then return end
	local playerPos = root.Position
	local bubus = getBubuModels()
	local nearest = nil
	local nearestDist = TAKE_BUBU_MAX_RANGE
	for _, model in ipairs(bubus) do
		local pos = nil
		local ok, pivot = pcall(function() return model:GetPivot() end)
		if ok and pivot then pos = pivot.Position
		elseif model.PrimaryPart then pos = model.PrimaryPart.Position
		end
		if not pos then continue end
		local dist = (pos - playerPos).Magnitude
		if dist < nearestDist then
			nearestDist = dist
			nearest = model
		end
	end
	local startPos = root.Position
	local x, y = startPos.X, startPos.Y
	task.spawn(function()
		local char = LocalPlayer.Character
		if not char then if onArrived then onArrived() end return end
		local humanoid = char:FindFirstChildOfClass("Humanoid")
		local r = char:FindFirstChild("HumanoidRootPart")
		if not humanoid or not r then if onArrived then onArrived() end return end
		task.wait(0.05)
		holdEKey(HOLD_E_DURATION)
		local moveToTarget = Vector3.new(x, y, -10)
		humanoid:MoveTo(moveToTarget)
		local start = os.clock()
		local lastZ = r.Position.Z
		local lastZTime = start
		local arrived = false
		local sKeyHeld = false
		while (os.clock() - start) < WALK_TO_OUTSIDE_TIMEOUT do
			local dist = (r.Position - moveToTarget).Magnitude
			if dist <= WALK_ARRIVED_DISTANCE then
				arrived = true
				if sKeyHeld then releaseSUp() end
				if dist <= WALK_ARRIVED_DISTANCE * 2 then
					r.CFrame = CFrame.new(moveToTarget)
				end
				break
			end
			local now = os.clock()
			local currentZ = r.Position.Z
			if math.abs(currentZ - lastZ) <= Z_STUCK_THRESHOLD then
				if (now - lastZTime) >= Z_STUCK_TIME and not sKeyHeld then
					local dir = (moveToTarget - r.Position).Unit
					r.CFrame = CFrame.lookAt(r.Position, r.Position + Vector3.new(dir.X, 0, dir.Z))
					pressSDown()
					sKeyHeld = true
					lastZTime = now
				end
			else
				lastZ = currentZ
				lastZTime = now
			end
			task.wait(0.2)
		end
		if sKeyHeld then releaseSUp() end
		if arrived and nearest then releasePickupState(nearest) end
		if onArrived then onArrived() end
	end)
end

-- Full flow: teleport to top Bubu → hold E → take nearest Bubu and MoveTo outside. Optional onArrived() when arrived.
local function goToTopThenTakeAndTeleportOutside(onArrived)
	local topPos = getTopBubuPosition()
	if not topPos then if onArrived then onArrived() end return end
	local character = LocalPlayer.Character
	if not character then if onArrived then onArrived() end return end
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then if onArrived then onArrived() end return end
	-- 1) Teleport to top Bubu (you are now near the best NPC)
	root.CFrame = CFrame.new(topPos)
	-- 2) Hold E to pick up the NPC (short hold so we start moving soon)
	holdEKey(HOLD_E_DURATION)
	-- 3) Walk to (same X, same Y, -10); character keeps moving until outside
	takeNearestBubuAndTeleportOutside(onArrived)
end

local main = Instance.new("Frame")
main.Name = "Main"
main.Size = UDim2.new(0, 220, 0, 300)
main.Position = UDim2.new(0, 16, 0, 16)
main.BackgroundColor3 = Color3.fromRGB(20, 30, 50)
main.BorderSizePixel = 0
main.Active = true  -- allow dragging from window background
main.Parent = screen

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 10)
corner.Parent = main

-- Top bar (drag handle)
local top = Instance.new("Frame")
top.Name = "Top"
top.Size = UDim2.new(1, 0, 0, 28)
top.Position = UDim2.new(0, 0, 0, 0)
top.BackgroundColor3 = Color3.fromRGB(30, 60, 100)
top.BorderSizePixel = 0
top.Active = true  -- required for InputBegan to fire on drag handle
top.Parent = main

local topCorner = Instance.new("UICorner")
topCorner.CornerRadius = UDim.new(0, 10)
topCorner.Parent = top

local topCover = Instance.new("Frame")
topCover.Size = UDim2.new(1, 0, 0, 14)
topCover.Position = UDim2.new(0, 0, 1, -14)
topCover.BackgroundColor3 = Color3.fromRGB(30, 60, 100)
topCover.BorderSizePixel = 0
topCover.Parent = top

local bar = Instance.new("Frame")
bar.Name = "Bar"
bar.Size = UDim2.new(1, 0, 0, 4)
bar.Position = UDim2.new(0, 0, 0, 28)
bar.BackgroundColor3 = Color3.fromRGB(90, 170, 255)
bar.BorderSizePixel = 0
bar.Active = true  -- drag handle
bar.Parent = main

local barCorner = Instance.new("UICorner")
barCorner.CornerRadius = UDim.new(0, 2)
barCorner.Parent = bar

local title = Instance.new("TextLabel")
title.Name = "Title"
title.Size = UDim2.new(1, -44, 0, 28)
title.Position = UDim2.new(0, 8, 0, 0)
title.BackgroundTransparency = 1
title.Active = true  -- required for InputBegan to fire on drag handle
title.Text = "Player Name Yoda"
title.TextColor3 = Color3.fromRGB(200, 230, 255)
title.TextSize = 14
title.Font = Enum.Font.GothamBold
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = top

local closeBtn = Instance.new("TextButton")
closeBtn.Name = "Close"
closeBtn.Size = UDim2.new(0, 28, 0, 28)
closeBtn.Position = UDim2.new(1, -28, 0, 0)
closeBtn.BackgroundTransparency = 1
closeBtn.Text = "×"
closeBtn.TextColor3 = Color3.fromRGB(200, 230, 255)
closeBtn.TextSize = 20
closeBtn.Font = Enum.Font.GothamBold
closeBtn.Parent = top

-- Drag state and connection (so we can disconnect when UI closes)
local mainDragging = false
local dragStart, startPos
local inputChangedConnection, inputEndedConnection

local function startDrag(inp)
	if inp.UserInputType == Enum.UserInputType.MouseButton1 then
		mainDragging = true
		dragStart = inp.Position
		startPos = main.Position
	end
end

-- Connect drag to top bar, title, bar, and main window background
top.InputBegan:Connect(startDrag)
title.InputBegan:Connect(startDrag)
bar.InputBegan:Connect(startDrag)
main.InputBegan:Connect(startDrag)

inputChangedConnection = UserInputService.InputChanged:Connect(function(inp)
	if mainDragging and inp.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = inp.Position - dragStart
		main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
end)

inputEndedConnection = UserInputService.InputEnded:Connect(function(inp)
	if inp.UserInputType == Enum.UserInputType.MouseButton1 then
		mainDragging = false
	end
end)

closeBtn.MouseButton1Click:Connect(function()
	if inputChangedConnection then inputChangedConnection:Disconnect() inputChangedConnection = nil end
	if inputEndedConnection then inputEndedConnection:Disconnect() inputEndedConnection = nil end
	if positionConnection then positionConnection:Disconnect() positionConnection = nil end
	screen:Destroy()
end)

local nameLabel = Instance.new("TextLabel")
nameLabel.Name = "PlayerName"
nameLabel.Size = UDim2.new(1, -16, 0, 24)
nameLabel.Position = UDim2.new(0, 8, 0, 36)
nameLabel.BackgroundTransparency = 1
nameLabel.Text = getPlayerName()
nameLabel.TextColor3 = Color3.new(1, 1, 1)
nameLabel.TextSize = 16
nameLabel.Font = Enum.Font.Gotham
nameLabel.TextXAlignment = Enum.TextXAlignment.Left
nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
nameLabel.Parent = main

-- Keep UI in sync if display name or name changes
LocalPlayer:GetPropertyChangedSignal("Name"):Connect(function()
	nameLabel.Text = getPlayerName()
end)

-- Speed slider
local speedLabel = Instance.new("TextLabel")
speedLabel.Name = "SpeedLabel"
speedLabel.Size = UDim2.new(0, 60, 0, 20)
speedLabel.Position = UDim2.new(0, 8, 0, 64)
speedLabel.BackgroundTransparency = 1
speedLabel.Text = "Speed"
speedLabel.TextColor3 = Color3.fromRGB(200, 230, 255)
speedLabel.TextSize = 12
speedLabel.Font = Enum.Font.Gotham
speedLabel.TextXAlignment = Enum.TextXAlignment.Left
speedLabel.Parent = main

local speedValueLabel = Instance.new("TextLabel")
speedValueLabel.Name = "SpeedValue"
speedValueLabel.Size = UDim2.new(0, 44, 0, 20)
speedValueLabel.Position = UDim2.new(1, -52, 0, 64)
speedValueLabel.BackgroundTransparency = 1
speedValueLabel.Text = tostring(DEFAULT_WALK_SPEED)
speedValueLabel.TextColor3 = Color3.fromRGB(200, 230, 255)
speedValueLabel.TextSize = 12
speedValueLabel.Font = Enum.Font.Gotham
speedValueLabel.TextXAlignment = Enum.TextXAlignment.Right
speedValueLabel.Parent = main

local sliderTrack = Instance.new("Frame")
sliderTrack.Name = "SliderTrack"
sliderTrack.Size = UDim2.new(1, -16, 0, 12)
sliderTrack.Position = UDim2.new(0, 8, 0, 88)
sliderTrack.BackgroundColor3 = Color3.fromRGB(40, 50, 70)
sliderTrack.BorderSizePixel = 0
sliderTrack.Active = true
sliderTrack.Parent = main

local sliderTrackCorner = Instance.new("UICorner")
sliderTrackCorner.CornerRadius = UDim.new(0, 6)
sliderTrackCorner.Parent = sliderTrack

local sliderFill = Instance.new("Frame")
sliderFill.Name = "Fill"
sliderFill.Size = UDim2.new(0, 0, 1, 0)
sliderFill.Position = UDim2.new(0, 0, 0, 0)
sliderFill.BackgroundColor3 = Color3.fromRGB(90, 170, 255)
sliderFill.BorderSizePixel = 0
sliderFill.ZIndex = 0
sliderFill.Parent = sliderTrack

local sliderFillCorner = Instance.new("UICorner")
sliderFillCorner.CornerRadius = UDim.new(0, 6)
sliderFillCorner.Parent = sliderFill

local sliderThumb = Instance.new("Frame")
sliderThumb.Name = "Thumb"
sliderThumb.Size = UDim2.new(0, 14, 0, 14)
sliderThumb.Position = UDim2.new(0, -7, 0.5, -7)
sliderThumb.AnchorPoint = Vector2.new(0.5, 0.5)
sliderThumb.BackgroundColor3 = Color3.fromRGB(200, 230, 255)
sliderThumb.BorderSizePixel = 0
sliderThumb.ZIndex = 1
sliderThumb.Active = true
sliderThumb.Parent = sliderTrack

local sliderThumbCorner = Instance.new("UICorner")
sliderThumbCorner.CornerRadius = UDim.new(1, 0)
sliderThumbCorner.Parent = sliderThumb

-- Objects list button
local objectsBtn = Instance.new("TextButton")
objectsBtn.Name = "Objects"
objectsBtn.Size = UDim2.new(1, -16, 0, 28)
objectsBtn.Position = UDim2.new(0, 8, 0, 108)
objectsBtn.BackgroundColor3 = Color3.fromRGB(40, 70, 120)
objectsBtn.BorderSizePixel = 0
objectsBtn.Text = "Spawned Bubus"
objectsBtn.TextColor3 = Color3.fromRGB(200, 230, 255)
objectsBtn.TextSize = 12
objectsBtn.Font = Enum.Font.Gotham
objectsBtn.Parent = main

local objectsBtnCorner = Instance.new("UICorner")
objectsBtnCorner.CornerRadius = UDim.new(0, 6)
objectsBtnCorner.Parent = objectsBtn

-- Collect All Cash button (calls ReplicatedStorage.CollectAllCash)
local collectCashBtn = Instance.new("TextButton")
collectCashBtn.Name = "CollectCash"
collectCashBtn.Size = UDim2.new(1, -16, 0, 28)
collectCashBtn.Position = UDim2.new(0, 8, 0, 140)
collectCashBtn.BackgroundColor3 = Color3.fromRGB(50, 90, 60)
collectCashBtn.BorderSizePixel = 0
collectCashBtn.Text = "Collect All Cash"
collectCashBtn.TextColor3 = Color3.fromRGB(200, 255, 220)
collectCashBtn.TextSize = 12
collectCashBtn.Font = Enum.Font.Gotham
collectCashBtn.Parent = main

local collectCashBtnCorner = Instance.new("UICorner")
collectCashBtnCorner.CornerRadius = UDim.new(0, 6)
collectCashBtnCorner.Parent = collectCashBtn

-- Scan Fuse button (main screen) – opens a draggable window with scrollable list of Fuse-related objects
local scanFuseBtn = Instance.new("TextButton")
scanFuseBtn.Name = "ScanFuse"
scanFuseBtn.Size = UDim2.new(1, -16, 0, 28)
scanFuseBtn.Position = UDim2.new(0, 8, 0, 172)
scanFuseBtn.BackgroundColor3 = Color3.fromRGB(90, 70, 40)
scanFuseBtn.BorderSizePixel = 0
scanFuseBtn.Text = "Scan Fuse"
scanFuseBtn.TextColor3 = Color3.fromRGB(255, 230, 180)
scanFuseBtn.TextSize = 12
scanFuseBtn.Font = Enum.Font.Gotham
scanFuseBtn.Parent = main

local scanFuseBtnCorner = Instance.new("UICorner")
scanFuseBtnCorner.CornerRadius = UDim.new(0, 6)
scanFuseBtnCorner.Parent = scanFuseBtn

-- Go to top button (main screen) – same as in Spawned Bubus: teleport to top Bubu, then take + teleport outside after 2s
local goToTopBtn = Instance.new("TextButton")
goToTopBtn.Name = "GoToTop"
goToTopBtn.Size = UDim2.new(0.5, -10, 0, 28)
goToTopBtn.Position = UDim2.new(0, 8, 0, 206)
goToTopBtn.BackgroundColor3 = Color3.fromRGB(50, 80, 120)
goToTopBtn.BorderSizePixel = 0
goToTopBtn.Text = "Go to top"
goToTopBtn.TextColor3 = Color3.fromRGB(200, 230, 255)
goToTopBtn.TextSize = 12
goToTopBtn.Font = Enum.Font.Gotham
goToTopBtn.Parent = main

local goToTopBtnCorner = Instance.new("UICorner")
goToTopBtnCorner.CornerRadius = UDim.new(0, 6)
goToTopBtnCorner.Parent = goToTopBtn

-- Teleport back button (main screen) – teleport to outside field position
local teleportBackBtn = Instance.new("TextButton")
teleportBackBtn.Name = "TeleportBack"
teleportBackBtn.Size = UDim2.new(0.5, -10, 0, 28)
teleportBackBtn.Position = UDim2.new(0.5, 2, 0, 206)
teleportBackBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 90)
teleportBackBtn.BorderSizePixel = 0
teleportBackBtn.Text = "Teleport back"
teleportBackBtn.TextColor3 = Color3.fromRGB(230, 200, 255)
teleportBackBtn.TextSize = 11
teleportBackBtn.Font = Enum.Font.Gotham
teleportBackBtn.Parent = main

local teleportBackBtnCorner = Instance.new("UICorner")
teleportBackBtnCorner.CornerRadius = UDim.new(0, 6)
teleportBackBtnCorner.Parent = teleportBackBtn

-- Start collecting NPCs button (under Go to top row)
local startCollectBtn = Instance.new("TextButton")
startCollectBtn.Name = "StartCollect"
startCollectBtn.Size = UDim2.new(0.5, -10, 0, 28)
startCollectBtn.Position = UDim2.new(0, 8, 0, 240)
startCollectBtn.BackgroundColor3 = Color3.fromRGB(40, 90, 50)
startCollectBtn.BorderSizePixel = 0
startCollectBtn.Text = "Start collecting NPCs"
startCollectBtn.TextColor3 = Color3.fromRGB(200, 255, 220)
startCollectBtn.TextSize = 10
startCollectBtn.Font = Enum.Font.Gotham
startCollectBtn.Parent = main

local startCollectBtnCorner = Instance.new("UICorner")
startCollectBtnCorner.CornerRadius = UDim.new(0, 6)
startCollectBtnCorner.Parent = startCollectBtn

-- Stop collecting NPCs button
local stopCollectBtn = Instance.new("TextButton")
stopCollectBtn.Name = "StopCollect"
stopCollectBtn.Size = UDim2.new(0.5, -10, 0, 28)
stopCollectBtn.Position = UDim2.new(0.5, 2, 0, 240)
stopCollectBtn.BackgroundColor3 = Color3.fromRGB(90, 40, 40)
stopCollectBtn.BorderSizePixel = 0
stopCollectBtn.Text = "Stop collecting"
stopCollectBtn.TextColor3 = Color3.fromRGB(255, 200, 200)
stopCollectBtn.TextSize = 11
stopCollectBtn.Font = Enum.Font.Gotham
stopCollectBtn.Parent = main

local stopCollectBtnCorner = Instance.new("UICorner")
stopCollectBtnCorner.CornerRadius = UDim.new(0, 6)
stopCollectBtnCorner.Parent = stopCollectBtn

local collectingActive = false
local function runCollectingLoop()
	while collectingActive do
		local list = getSortedBubuListTopLevel()
		if #list == 0 then
			task.wait(2)
		else
			local arrived = false
			goToTopThenTakeAndTeleportOutside(function() arrived = true end)
			while not arrived and collectingActive do
				task.wait(0.5)
			end
			if not collectingActive then break end
			task.wait(1)
		end
	end
end

-- Player position display
local positionLabel = Instance.new("TextLabel")
positionLabel.Name = "Position"
positionLabel.Size = UDim2.new(1, -16, 0, 20)
positionLabel.Position = UDim2.new(0, 8, 0, 274)
positionLabel.BackgroundTransparency = 1
positionLabel.Text = "Position: --, --, --"
positionLabel.TextColor3 = Color3.fromRGB(180, 210, 255)
positionLabel.TextSize = 11
positionLabel.Font = Enum.Font.Gotham
positionLabel.TextXAlignment = Enum.TextXAlignment.Left
positionLabel.TextTruncate = Enum.TextTruncate.AtEnd
positionLabel.Parent = main

local positionConnection
local function updatePositionDisplay()
	local character = LocalPlayer.Character
	if not character then
		positionLabel.Text = "Position: (no character)"
		return
	end
	local root = character:FindFirstChild("HumanoidRootPart")
	if not root then
		positionLabel.Text = "Position: (no root)"
		return
	end
	local p = root.Position
	positionLabel.Text = string.format("Position: %.1f, %.1f, %.1f", p.X, p.Y, p.Z)
end
positionConnection = RunService.Heartbeat:Connect(updatePositionDisplay)
updatePositionDisplay()

-- Objects list window (new window when button clicked)
local function openObjectsWindow()
	local existingObjGui = PlayerGui:FindFirstChild("PlayerNameTest_ObjectsList")
	if existingObjGui then
		existingObjGui:Destroy()
	end

	local objScreen = Instance.new("ScreenGui")
	objScreen.Name = "PlayerNameTest_ObjectsList"
	objScreen.ResetOnSpawn = false
	objScreen.Parent = PlayerGui

	local objMain = Instance.new("Frame")
	objMain.Name = "Main"
	objMain.Size = UDim2.new(0, 320, 0, 400)
	objMain.Position = UDim2.new(0.5, -160, 0.5, -200)
	objMain.AnchorPoint = Vector2.new(0.5, 0.5)
	objMain.BackgroundColor3 = Color3.fromRGB(20, 30, 50)
	objMain.BorderSizePixel = 0
	objMain.Active = true  -- allow dragging from window background
	objMain.Parent = objScreen

	local objCorner = Instance.new("UICorner")
	objCorner.CornerRadius = UDim.new(0, 10)
	objCorner.Parent = objMain

	local objTop = Instance.new("Frame")
	objTop.Name = "Top"
	objTop.Size = UDim2.new(1, 0, 0, 28)
	objTop.Position = UDim2.new(0, 0, 0, 0)
	objTop.BackgroundColor3 = Color3.fromRGB(30, 60, 100)
	objTop.BorderSizePixel = 0
	objTop.Active = true
	objTop.Parent = objMain

	local objTopCorner = Instance.new("UICorner")
	objTopCorner.CornerRadius = UDim.new(0, 10)
	objTopCorner.Parent = objTop

	local objTitle = Instance.new("TextLabel")
	objTitle.Name = "Title"
	objTitle.Size = UDim2.new(1, -148, 0, 28)
	objTitle.Position = UDim2.new(0, 8, 0, 0)
	objTitle.BackgroundTransparency = 1
	objTitle.Active = true
	objTitle.Text = "Spawned Bubus"
	objTitle.TextColor3 = Color3.fromRGB(200, 230, 255)
	objTitle.TextSize = 14
	objTitle.Font = Enum.Font.GothamBold
	objTitle.TextXAlignment = Enum.TextXAlignment.Left
	objTitle.Parent = objTop

	local objCloseBtn = Instance.new("TextButton")
	objCloseBtn.Name = "Close"
	objCloseBtn.Size = UDim2.new(0, 28, 0, 28)
	objCloseBtn.Position = UDim2.new(1, -28, 0, 0)
	objCloseBtn.BackgroundTransparency = 1
	objCloseBtn.Text = "×"
	objCloseBtn.TextColor3 = Color3.fromRGB(200, 230, 255)
	objCloseBtn.TextSize = 20
	objCloseBtn.Font = Enum.Font.GothamBold
	objCloseBtn.Parent = objTop

	-- Drag for objects window
	local objDragging = false
	local objDragStart, objStartPos
	local objInputChangedConn, objInputEndedConn
	local function onObjDragStart(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 then
			objDragging = true
			objDragStart = inp.Position
			objStartPos = objMain.Position
		end
	end
	objTop.InputBegan:Connect(onObjDragStart)
	objTitle.InputBegan:Connect(onObjDragStart)
	objMain.InputBegan:Connect(onObjDragStart)
	objInputChangedConn = UserInputService.InputChanged:Connect(function(inp)
		if objDragging and inp.UserInputType == Enum.UserInputType.MouseMovement then
			local delta = inp.Position - objDragStart
			objMain.Position = UDim2.new(objStartPos.X.Scale, objStartPos.X.Offset + delta.X, objStartPos.Y.Scale, objStartPos.Y.Offset + delta.Y)
		end
	end)
	objInputEndedConn = UserInputService.InputEnded:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 then
			objDragging = false
		end
	end)

	objCloseBtn.MouseButton1Click:Connect(function()
		if objInputChangedConn then objInputChangedConn:Disconnect() end
		if objInputEndedConn then objInputEndedConn:Disconnect() end
		objScreen:Destroy()
	end)

	-- List remotes button (prints to Output so you can set TAKE_REMOTE_PATH)
	local objRemotesBtn = Instance.new("TextButton")
	objRemotesBtn.Name = "Remotes"
	objRemotesBtn.Size = UDim2.new(0, 58, 0, 28)
	objRemotesBtn.Position = UDim2.new(1, -250, 0, 0)
	objRemotesBtn.BackgroundTransparency = 1
	objRemotesBtn.Text = "Remotes"
	objRemotesBtn.TextColor3 = Color3.fromRGB(180, 200, 255)
	objRemotesBtn.TextSize = 11
	objRemotesBtn.Font = Enum.Font.Gotham
	objRemotesBtn.Parent = objTop

	-- Refresh button (manual refresh only)
	local objRefreshBtn = Instance.new("TextButton")
	objRefreshBtn.Name = "Refresh"
	objRefreshBtn.Size = UDim2.new(0, 56, 0, 28)
	objRefreshBtn.Position = UDim2.new(1, -168, 0, 0)
	objRefreshBtn.BackgroundTransparency = 1
	objRefreshBtn.Text = "Refresh"
	objRefreshBtn.TextColor3 = Color3.fromRGB(200, 230, 255)
	objRefreshBtn.TextSize = 12
	objRefreshBtn.Font = Enum.Font.Gotham
	objRefreshBtn.Parent = objTop

	-- Teleport to top Bubu button
	local objTeleportBtn = Instance.new("TextButton")
	objTeleportBtn.Name = "Teleport"
	objTeleportBtn.Size = UDim2.new(0, 70, 0, 28)
	objTeleportBtn.Position = UDim2.new(1, -106, 0, 0)
	objTeleportBtn.BackgroundTransparency = 1
	objTeleportBtn.Text = "Go to top"
	objTeleportBtn.TextColor3 = Color3.fromRGB(200, 230, 255)
	objTeleportBtn.TextSize = 11
	objTeleportBtn.Font = Enum.Font.Gotham
	objTeleportBtn.Parent = objTop

	-- Scrollable list (full width)
	local scroll = Instance.new("ScrollingFrame")
	scroll.Name = "List"
	scroll.Size = UDim2.new(1, -16, 1, -44)
	scroll.Position = UDim2.new(0, 8, 0, 36)
	scroll.BackgroundColor3 = Color3.fromRGB(25, 35, 55)
	scroll.BorderSizePixel = 0
	scroll.ScrollBarThickness = 6
	scroll.ScrollBarImageColor3 = Color3.fromRGB(90, 170, 255)
	scroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	scroll.AutomaticCanvasSize = Enum.AutomaticSize.Y
	scroll.Parent = objMain

	local scrollCorner = Instance.new("UICorner")
	scrollCorner.CornerRadius = UDim.new(0, 6)
	scrollCorner.Parent = scroll

	local listLayout = Instance.new("UIListLayout")
	listLayout.Padding = UDim.new(0, 2)
	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
	listLayout.Parent = scroll

	local workspace = game:GetService("Workspace")
	local ROW_HEIGHT = 22

	-- Get text from CharacterInfo BillboardGui label by name (e.g. "Rarity", "Income", "CharTime")
	local function getCharacterInfoLabel(model, labelName)
		for _, desc in ipairs(model:GetDescendants()) do
			if desc:IsA("BillboardGui") and desc.Name == "CharacterInfo" then
				local lbl = desc:FindFirstChild(labelName, true)
				if lbl and (lbl:IsA("TextLabel") or lbl:IsA("TextButton")) and lbl.Text then
					return lbl.Text
				end
				break
			end
		end
		local charInfo = model:FindFirstChild("CharacterInfo", true)
		if charInfo then
			local gui = charInfo:IsA("BillboardGui") and charInfo or charInfo:FindFirstChildOfClass("BillboardGui")
			if gui then
				local lbl = gui:FindFirstChild(labelName, true)
				if lbl and (lbl:IsA("TextLabel") or lbl:IsA("TextButton")) and lbl.Text then
					return lbl.Text
				end
			end
		end
		return nil
	end

	-- List row: NPCId - Mutation - Rarity - Income - CharTime (no click needed to see info)
	local function getNPCDisplayLabel(model)
		local npcId = tostring(model:GetAttribute("NPCId") or "?")
		local mutation = tostring(model:GetAttribute("Mutation") or "?")
		local rarity = getCharacterInfoLabel(model, "Rarity") or "?"
		local income = getCharacterInfoLabel(model, "Income") or "?"
		local charTime = getCharacterInfoLabel(model, "CharTime") or "?"
		return npcId .. " - " .. mutation .. " - " .. rarity .. " - " .. income .. " - " .. charTime
	end

	local function addRow(model, layoutOrder)
		local row = Instance.new("TextButton")
		row.Name = model.Name
		row.Size = UDim2.new(1, -8, 0, ROW_HEIGHT)
		row.BackgroundColor3 = Color3.fromRGB(35, 50, 75)
		row.BorderSizePixel = 0
		row.LayoutOrder = layoutOrder
		row.Text = ""
		row.AutoButtonColor = true
		row.Parent = scroll
		local rowCorner = Instance.new("UICorner")
		rowCorner.CornerRadius = UDim.new(0, 4)
		rowCorner.Parent = row
		local lbl = Instance.new("TextLabel")
		lbl.Size = UDim2.new(1, -8, 1, -4)
		lbl.Position = UDim2.new(0, 6, 0, 2)
		lbl.BackgroundTransparency = 1
		lbl.Text = getNPCDisplayLabel(model)
		lbl.TextColor3 = Color3.fromRGB(200, 220, 255)
		lbl.TextSize = 11
		lbl.Font = Enum.Font.Gotham
		lbl.TextXAlignment = Enum.TextXAlignment.Left
		lbl.TextTruncate = Enum.TextTruncate.AtEnd
		lbl.Parent = row
		return row
	end

	-- Use same filtered list as collection (excludes Gold/Diamond when rarity is Common/Uncommon/Rare, etc.)
	local function getSortedBubuList()
		return getSortedBubuListTopLevel()
	end

	local function teleportToTopBubu()
		local character = LocalPlayer.Character
		if not character then return end
		local root = character:FindFirstChild("HumanoidRootPart")
		if not root then return end
		local sorted = getSortedBubuList()
		if #sorted == 0 then return end
		local topModel = sorted[1]
		local pos
		local ok, pivot = pcall(function() return topModel:GetPivot() end)
		if ok and pivot then
			pos = pivot.Position
		elseif topModel.PrimaryPart then
			pos = topModel.PrimaryPart.Position
		else
			return
		end
		-- Teleport 4 studs in front of the Bubu so player doesn't spawn inside it
		root.CFrame = CFrame.new(pos + Vector3.new(0, 0, 4))
	end

	local function refreshList()
		for _, child in ipairs(scroll:GetChildren()) do
			if child ~= listLayout then
				child:Destroy()
			end
		end
		local collected = getSortedBubuList()
		for i, model in ipairs(collected) do
			addRow(model, i)
		end
	end

	refreshList()

	objRemotesBtn.MouseButton1Click:Connect(function()
		listAllRemotes()
	end)

	objRefreshBtn.MouseButton1Click:Connect(refreshList)
	-- Go to top: script handles teleport to top Bubu + 2 sec wait + take Bubu + teleport outside (no E key)
	objTeleportBtn.MouseButton1Click:Connect(function()
		goToTopThenTakeAndTeleportOutside()
	end)

	-- Auto-refresh list every 2 seconds while window is open
	task.spawn(function()
		while objScreen.Parent do
			task.wait(2)
			if not objScreen.Parent then break end
			refreshList()
		end
	end)
end

-- Scan Fuse window: draggable, scrollable textbox with all Fuse-related object paths
local function openScanFuseWindow()
	local existing = PlayerGui:FindFirstChild("PlayerNameTest_ScanFuse")
	if existing then
		existing:Destroy()
	end

	local fuseScreen = Instance.new("ScreenGui")
	fuseScreen.Name = "PlayerNameTest_ScanFuse"
	fuseScreen.ResetOnSpawn = false
	fuseScreen.Parent = PlayerGui

	local fuseMain = Instance.new("Frame")
	fuseMain.Name = "Main"
	fuseMain.Size = UDim2.new(0, 360, 0, 380)
	fuseMain.Position = UDim2.new(0.5, -180, 0.5, -190)
	fuseMain.AnchorPoint = Vector2.new(0.5, 0.5)
	fuseMain.BackgroundColor3 = Color3.fromRGB(20, 30, 50)
	fuseMain.BorderSizePixel = 0
	fuseMain.Active = true
	fuseMain.Parent = fuseScreen

	local fuseCorner = Instance.new("UICorner")
	fuseCorner.CornerRadius = UDim.new(0, 10)
	fuseCorner.Parent = fuseMain

	local fuseTop = Instance.new("Frame")
	fuseTop.Name = "Top"
	fuseTop.Size = UDim2.new(1, 0, 0, 28)
	fuseTop.Position = UDim2.new(0, 0, 0, 0)
	fuseTop.BackgroundColor3 = Color3.fromRGB(30, 60, 100)
	fuseTop.BorderSizePixel = 0
	fuseTop.Active = true
	fuseTop.Parent = fuseMain

	local fuseTopCorner = Instance.new("UICorner")
	fuseTopCorner.CornerRadius = UDim.new(0, 10)
	fuseTopCorner.Parent = fuseTop

	local fuseTitle = Instance.new("TextLabel")
	fuseTitle.Name = "Title"
	fuseTitle.Size = UDim2.new(1, -44, 0, 28)
	fuseTitle.Position = UDim2.new(0, 8, 0, 0)
	fuseTitle.BackgroundTransparency = 1
	fuseTitle.Active = true
	fuseTitle.Text = "Scan Fuse – objects"
	fuseTitle.TextColor3 = Color3.fromRGB(255, 230, 180)
	fuseTitle.TextSize = 14
	fuseTitle.Font = Enum.Font.GothamBold
	fuseTitle.TextXAlignment = Enum.TextXAlignment.Left
	fuseTitle.Parent = fuseTop

	local fuseCloseBtn = Instance.new("TextButton")
	fuseCloseBtn.Name = "Close"
	fuseCloseBtn.Size = UDim2.new(0, 28, 0, 28)
	fuseCloseBtn.Position = UDim2.new(1, -28, 0, 0)
	fuseCloseBtn.BackgroundTransparency = 1
	fuseCloseBtn.Text = "×"
	fuseCloseBtn.TextColor3 = Color3.fromRGB(200, 230, 255)
	fuseCloseBtn.TextSize = 20
	fuseCloseBtn.Font = Enum.Font.GothamBold
	fuseCloseBtn.Parent = fuseTop

	-- Draggable
	local fuseDragging = false
	local fuseDragStart, fuseStartPos
	local fuseInputChangedConn, fuseInputEndedConn
	local function onFuseDragStart(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 then
			fuseDragging = true
			fuseDragStart = inp.Position
			fuseStartPos = fuseMain.Position
		end
	end
	fuseTop.InputBegan:Connect(onFuseDragStart)
	fuseTitle.InputBegan:Connect(onFuseDragStart)
	fuseMain.InputBegan:Connect(onFuseDragStart)
	fuseInputChangedConn = UserInputService.InputChanged:Connect(function(inp)
		if fuseDragging and inp.UserInputType == Enum.UserInputType.MouseMovement then
			local delta = inp.Position - fuseDragStart
			fuseMain.Position = UDim2.new(fuseStartPos.X.Scale, fuseStartPos.X.Offset + delta.X, fuseStartPos.Y.Scale, fuseStartPos.Y.Offset + delta.Y)
		end
	end)
	fuseInputEndedConn = UserInputService.InputEnded:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 then
			fuseDragging = false
		end
	end)

	fuseCloseBtn.MouseButton1Click:Connect(function()
		if fuseInputChangedConn then fuseInputChangedConn:Disconnect() end
		if fuseInputEndedConn then fuseInputEndedConn:Disconnect() end
		fuseScreen:Destroy()
	end)

	-- Scrollable text area (manual CanvasSize so scroll bar works)
	local fuseScroll = Instance.new("ScrollingFrame")
	fuseScroll.Name = "Scroll"
	fuseScroll.Size = UDim2.new(1, -16, 1, -88)
	fuseScroll.Position = UDim2.new(0, 8, 0, 36)
	fuseScroll.BackgroundColor3 = Color3.fromRGB(25, 35, 55)
	fuseScroll.BorderSizePixel = 0
	fuseScroll.ScrollBarThickness = 8
	fuseScroll.ScrollBarImageColor3 = Color3.fromRGB(90, 170, 255)
	fuseScroll.ScrollingDirection = Enum.ScrollingDirection.Y
	fuseScroll.CanvasSize = UDim2.new(0, 0, 0, 0)
	fuseScroll.Parent = fuseMain

	local fuseScrollCorner = Instance.new("UICorner")
	fuseScrollCorner.CornerRadius = UDim.new(0, 6)
	fuseScrollCorner.Parent = fuseScroll

	-- TextBox so you can select and copy (Ctrl+A, Ctrl+C). Read-only so you don't edit by accident.
	local fuseContent = Instance.new("TextBox")
	fuseContent.Name = "Content"
	fuseContent.Size = UDim2.new(1, -8, 0, 0)
	fuseContent.Position = UDim2.new(0, 4, 0, 4)
	fuseContent.BackgroundTransparency = 1
	fuseContent.Text = ""
	fuseContent.TextColor3 = Color3.fromRGB(200, 220, 255)
	fuseContent.TextSize = 11
	fuseContent.Font = Enum.Font.Code
	fuseContent.TextXAlignment = Enum.TextXAlignment.Left
	fuseContent.TextYAlignment = Enum.TextYAlignment.Top
	fuseContent.TextWrapped = true
	fuseContent.ClearTextOnFocus = false
	fuseContent.MultiLine = true
	fuseContent.TextEditable = false  -- read-only; you can still select and copy
	fuseContent.AutomaticSize = Enum.AutomaticSize.Y
	fuseContent.Parent = fuseScroll

	local function updateFuseCanvasSize()
		local contentY = fuseContent.AbsoluteSize.Y
		local scrollY = fuseScroll.AbsoluteWindowSize.Y
		fuseScroll.CanvasSize = UDim2.new(0, 0, 0, math.max(scrollY, contentY + 16))
	end

	fuseContent:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateFuseCanvasSize)

	-- Run scan and fill text
	local list = listObjectsInGame("Fuse")
	local text = #list > 0 and table.concat(list, "\n") or "(no objects containing \"Fuse\" found)"
	fuseContent.Text = text
	task.defer(updateFuseCanvasSize)

	-- Read Fuse UI: show current PossibleFrame + BringFrame content (open Fuse menu first)
	local fuseReadBtn = Instance.new("TextButton")
	fuseReadBtn.Name = "ReadFuseUI"
	fuseReadBtn.Size = UDim2.new(0.5, -12, 0, 26)
	fuseReadBtn.Position = UDim2.new(0, 8, 1, -52)
	fuseReadBtn.BackgroundColor3 = Color3.fromRGB(50, 70, 100)
	fuseReadBtn.BorderSizePixel = 0
	fuseReadBtn.Text = "Read Fuse UI"
	fuseReadBtn.TextColor3 = Color3.fromRGB(200, 220, 255)
	fuseReadBtn.TextSize = 11
	fuseReadBtn.Font = Enum.Font.Gotham
	fuseReadBtn.Parent = fuseMain
	local fuseReadBtnCorner = Instance.new("UICorner")
	fuseReadBtnCorner.CornerRadius = UDim.new(0, 6)
	fuseReadBtnCorner.Parent = fuseReadBtn
	fuseReadBtn.MouseButton1Click:Connect(function()
		fuseContent.Text = readFuseFrameContent()
		task.defer(updateFuseCanvasSize)
	end)

	-- Find Fuse list: search client for fuse data (ModuleScripts, FuseData, attributes)
	local fuseFindBtn = Instance.new("TextButton")
	fuseFindBtn.Name = "FindFuseList"
	fuseFindBtn.Size = UDim2.new(0.5, -12, 0, 26)
	fuseFindBtn.Position = UDim2.new(0.5, 4, 1, -52)
	fuseFindBtn.BackgroundColor3 = Color3.fromRGB(60, 50, 80)
	fuseFindBtn.BorderSizePixel = 0
	fuseFindBtn.Text = "Find Fuse list (client)"
	fuseFindBtn.TextColor3 = Color3.fromRGB(220, 200, 255)
	fuseFindBtn.TextSize = 10
	fuseFindBtn.Font = Enum.Font.Gotham
	fuseFindBtn.Parent = fuseMain
	local fuseFindBtnCorner = Instance.new("UICorner")
	fuseFindBtnCorner.CornerRadius = UDim.new(0, 6)
	fuseFindBtnCorner.Parent = fuseFindBtn
	fuseFindBtn.MouseButton1Click:Connect(function()
		fuseContent.Text = findFuseDataOnClient()
		task.defer(updateFuseCanvasSize)
	end)

	-- Hint for copying
	local fuseTip = Instance.new("TextLabel")
	fuseTip.Name = "Tip"
	fuseTip.Size = UDim2.new(1, -16, 0, 14)
	fuseTip.Position = UDim2.new(0, 8, 1, -22)
	fuseTip.BackgroundTransparency = 1
	fuseTip.Text = "Ctrl+A then Ctrl+C (Cmd on Mac) to copy."
	fuseTip.TextColor3 = Color3.fromRGB(140, 160, 180)
	fuseTip.TextSize = 10
	fuseTip.Font = Enum.Font.Gotham
	fuseTip.TextXAlignment = Enum.TextXAlignment.Left
	fuseTip.Parent = fuseMain
end

objectsBtn.MouseButton1Click:Connect(openObjectsWindow)
scanFuseBtn.MouseButton1Click:Connect(openScanFuseWindow)

-- Collect All Cash: call ReplicatedStorage.CollectAllCash (RemoteEvent or RemoteFunction)
collectCashBtn.MouseButton1Click:Connect(function()
	local collectAllCash = ReplicatedStorage:FindFirstChild("CollectAllCash")
	if not collectAllCash then
		warn("[CollectAllCash] ReplicatedStorage.CollectAllCash not found")
		return
	end
	local ok, err = pcall(function()
		if collectAllCash:IsA("RemoteEvent") then
			collectAllCash:FireServer()
		elseif collectAllCash:IsA("RemoteFunction") then
			collectAllCash:InvokeServer()
		else
			warn("[CollectAllCash] CollectAllCash is not a RemoteEvent or RemoteFunction")
		end
	end)
	if not ok then
		warn("[CollectAllCash] Error:", err)
	end
end)

goToTopBtn.MouseButton1Click:Connect(function()
	goToTopThenTakeAndTeleportOutside()
end)

startCollectBtn.MouseButton1Click:Connect(function()
	if collectingActive then return end
	collectingActive = true
	task.spawn(runCollectingLoop)
end)

stopCollectBtn.MouseButton1Click:Connect(function()
	collectingActive = false
end)

teleportBackBtn.MouseButton1Click:Connect(function()
	local character = LocalPlayer.Character
	if not character then return end
	local root = character:FindFirstChild("HumanoidRootPart")
	if root then
		root.CFrame = CFrame.new(OUTSIDE_FIELD_POSITION)
	end
end)

-- Current speed value (0–1)
local speedNorm = (DEFAULT_WALK_SPEED - MIN_WALK_SPEED) / (MAX_WALK_SPEED - MIN_WALK_SPEED)

local function speedFromNorm(norm)
	norm = math.clamp(norm, 0, 1)
	return math.floor(MIN_WALK_SPEED + (MAX_WALK_SPEED - MIN_WALK_SPEED) * norm + 0.5)
end

local function normFromSpeed(speed)
	return (math.clamp(speed, MIN_WALK_SPEED, MAX_WALK_SPEED) - MIN_WALK_SPEED) / (MAX_WALK_SPEED - MIN_WALK_SPEED)
end

local function applySpeedToCharacter(speed)
	local character = LocalPlayer.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			humanoid.WalkSpeed = speed
		end
	end
end

local function setSpeedFromNorm(norm)
	norm = math.clamp(norm, 0, 1)
	speedNorm = norm
	local speed = speedFromNorm(norm)
	speedValueLabel.Text = tostring(speed)
	sliderFill.Size = UDim2.new(norm, 0, 1, 0)
	sliderThumb.Position = UDim2.new(norm, -7, 0.5, -7)
	applySpeedToCharacter(speed)
end

local function updateSliderFromMouse(x)
	local trackAbs = sliderTrack.AbsolutePosition.X
	local trackSize = sliderTrack.AbsoluteSize.X
	local rel = (x - trackAbs) / math.max(trackSize, 1)
	setSpeedFromNorm(rel)
end

-- Slider drag state
local sliderDragging = false
local sliderInputConnection

local function beginSliderDrag()
	sliderDragging = true
	sliderInputConnection = UserInputService.InputChanged:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseMovement then
			-- Only update slider when mouse is over the track
			local trackPos = sliderTrack.AbsolutePosition
			local trackSize = sliderTrack.AbsoluteSize
			local x, y = inp.Position.X, inp.Position.Y
			if x >= trackPos.X and x <= trackPos.X + trackSize.X and y >= trackPos.Y and y <= trackPos.Y + trackSize.Y then
				updateSliderFromMouse(x)
			end
		end
	end)
	local endConn
	endConn = UserInputService.InputEnded:Connect(function(inp)
		if inp.UserInputType == Enum.UserInputType.MouseButton1 then
			sliderDragging = false
			if sliderInputConnection then sliderInputConnection:Disconnect() end
			endConn:Disconnect()
		end
	end)
end

sliderTrack.InputBegan:Connect(function(inp)
	if inp.UserInputType == Enum.UserInputType.MouseButton1 then
		updateSliderFromMouse(inp.Position.X)
		beginSliderDrag()
	end
end)

sliderThumb.InputBegan:Connect(function(inp)
	if inp.UserInputType == Enum.UserInputType.MouseButton1 then
		beginSliderDrag()
	end
end)

-- Initialize slider position and apply default speed
setSpeedFromNorm(speedNorm)

-- Apply speed when character spawns/respawns
LocalPlayer.CharacterAdded:Connect(function(character)
	local humanoid = character:WaitForChild("Humanoid", 5)
	if humanoid then
		humanoid.WalkSpeed = speedFromNorm(speedNorm)
	end
end)

-- If character already exists, set WalkSpeed once
if LocalPlayer.Character then
	applySpeedToCharacter(speedFromNorm(speedNorm))
end

print("Player name:", getPlayerName())
